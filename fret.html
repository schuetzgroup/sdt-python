

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Single molecule FRET analysis &mdash; sdt-python 14.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Image filtering and processing" href="image.html" />
    <link rel="prev" title="Analyze spatial aspects of data" href="spatial.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> sdt-python
          

          
          </a>

          
            
            
              <div class="version">
                14.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="roi.html">Regions of interest (ROIs)</a></li>
<li class="toctree-l1"><a class="reference internal" href="chromatic.html">Overlay color channels</a></li>
<li class="toctree-l1"><a class="reference internal" href="multicolor.html">Multi-color data analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="motion.html">Diffusion analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="brightness.html">Brightness analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="io.html">Data input/output</a></li>
<li class="toctree-l1"><a class="reference internal" href="changepoint.html">Changepoint detection</a></li>
<li class="toctree-l1"><a class="reference internal" href="spatial.html">Analyze spatial aspects of data</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Single molecule FRET analysis</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#tracking">Tracking</a></li>
<li class="toctree-l2"><a class="reference internal" href="#analysis-and-filtering">Analysis and Filtering</a></li>
<li class="toctree-l2"><a class="reference internal" href="#plotting">Plotting</a></li>
<li class="toctree-l2"><a class="reference internal" href="#image-selection">Image selection</a></li>
<li class="toctree-l2"><a class="reference internal" href="#helpers">Helpers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="image.html">Image filtering and processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="flatfield.html">Flat field correction</a></li>
<li class="toctree-l1"><a class="reference internal" href="loc.html">Fluorescent feature localization</a></li>
<li class="toctree-l1"><a class="reference internal" href="nbui.html">GUIs for the Jupyter notebook</a></li>
<li class="toctree-l1"><a class="reference internal" href="sim.html">Simulation of microscopy-related data</a></li>
<li class="toctree-l1"><a class="reference internal" href="funcs.html">Special functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="plot.html">Plotting utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="exp_fit.html">Fit of a sum of exponential functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="gaussian_fit.html">Fitting of 1D and 2D Gaussian functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="helper.html">Helpers for writing new code</a></li>
<li class="toctree-l1"><a class="reference internal" href="CHANGELOG.html">Change log</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">sdt-python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Single molecule FRET analysis</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <span class="target" id="module-sdt.fret"></span><div class="section" id="single-molecule-fret-analysis">
<h1>Single molecule FRET analysis<a class="headerlink" href="#single-molecule-fret-analysis" title="Permalink to this headline">Â¶</a></h1>
<p>The <a class="reference internal" href="#module-sdt.fret" title="sdt.fret"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sdt.fret</span></code></a> module provides functionality to analyze single
molecule FRET data. This includes</p>
<ul class="simple">
<li><p>tracking and measurement of FRET-related quantities using the
<a class="reference internal" href="#sdt.fret.SmFretTracker" title="sdt.fret.SmFretTracker"><code class="xref py py-class docutils literal notranslate"><span class="pre">SmFretTracker</span></code></a> class.</p></li>
<li><p>analyzing and filtering of the data with help of <a class="reference internal" href="#sdt.fret.SmFretAnalyzer" title="sdt.fret.SmFretAnalyzer"><code class="xref py py-class docutils literal notranslate"><span class="pre">SmFretAnalyzer</span></code></a>.</p></li>
<li><p>functions for plotting results, such as <a class="reference internal" href="#sdt.fret.smfret_scatter" title="sdt.fret.smfret_scatter"><code class="xref py py-func docutils literal notranslate"><span class="pre">smfret_scatter()</span></code></a>,
<a class="reference internal" href="#sdt.fret.smfret_hist" title="sdt.fret.smfret_hist"><code class="xref py py-func docutils literal notranslate"><span class="pre">smfret_hist()</span></code></a>, and <a class="reference internal" href="#sdt.fret.draw_track" title="sdt.fret.draw_track"><code class="xref py py-func docutils literal notranslate"><span class="pre">draw_track()</span></code></a>.</p></li>
<li><p>selection of images in a FRET sequence according to excitation type using
<code class="xref py py-class docutils literal notranslate"><span class="pre">FretImageSelector</span></code>.</p></li>
</ul>
<p class="rubric">Examples</p>
<p>Load data for tracking:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">chromatic_corr</span> <span class="o">=</span> <span class="n">sdt</span><span class="o">.</span><span class="n">chromatic</span><span class="o">.</span><span class="n">Corrector</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;cc.npz&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">donor_loc</span> <span class="o">=</span> <span class="n">sdt</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;donor.h5&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">acceptor_loc</span> <span class="o">=</span> <span class="n">sdt</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;acceptor.h5&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">donor_img</span> <span class="o">=</span> <span class="n">pims</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;donor.tif&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">acceptor_img</span> <span class="o">=</span> <span class="n">pims</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;acceptor.tif&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Tracking of single molecule FRET signals. This involves merging features
from donor and acceptor channels, the actual tracking, getting the
brightness of the donor and the acceptor for each localization from the
raw images and much more.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tracker</span> <span class="o">=</span> <span class="n">SmFretTracker</span><span class="p">(</span><span class="s2">&quot;dddda&quot;</span><span class="p">,</span> <span class="n">chromatic_corr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trc</span> <span class="o">=</span> <span class="n">tracker</span><span class="o">.</span><span class="n">track</span><span class="p">(</span><span class="n">donor_img</span><span class="p">,</span> <span class="n">acceptor_img</span><span class="p">,</span> <span class="n">donor_loc</span><span class="p">,</span> <span class="n">acceptor_loc</span><span class="p">)</span>
</pre></div>
</div>
<p>Now these data can be analyzed and filtered. Calculate FRET-related quantities
such as FRET efficiency, stoichiometry, etc.:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ana</span> <span class="o">=</span> <span class="n">SmFretAnalyzer</span><span class="p">(</span><span class="n">trc</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ana</span><span class="o">.</span><span class="n">analyze</span><span class="p">(</span><span class="n">trc</span><span class="p">)</span>
</pre></div>
</div>
<p>Let us reject any tracks where the
acceptor does not bleach in a single step and additionally remove all
features after the bleaching step:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ana</span><span class="o">.</span><span class="n">acceptor_bleach_step</span><span class="p">(</span><span class="n">brightness_thresh</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">penalty</span><span class="o">=</span><span class="mf">1e6</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">truncate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Remove any tracks where the mass upon acceptor excitation does not exceed
500 counts at least once</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ana</span><span class="o">.</span><span class="n">filter_particles</span><span class="p">(</span><span class="s2">&quot;fret_a_mass &gt; 500&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Accept only localizations that lie in pixels where the boolean mask is <cite>True</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;mask.npy&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ana</span><span class="o">.</span><span class="n">image_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="s2">&quot;donor&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Filtered data can be accessed via the <a class="reference internal" href="#sdt.fret.SmFretAnalyzer.tracks" title="sdt.fret.SmFretAnalyzer.tracks"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SmFretAnalyzer.tracks</span></code></a>
attribute.</p>
<p>Draw a scatter plot of FRET efficiency vs. stoichiometry:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">smfret_scatter</span><span class="p">({</span><span class="s2">&quot;data1&quot;</span><span class="p">:</span> <span class="n">filt</span><span class="o">.</span><span class="n">tracks</span><span class="p">},</span> <span class="p">(</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;eff), (&quot;</span><span class="n">fret</span><span class="s2">&quot;, &quot;</span><span class="n">stoi</span><span class="s2">&quot;))</span>
</pre></div>
</div>
<p>To get only the direct acceptor excitation images from <code class="docutils literal notranslate"><span class="pre">acceptor_img</span></code>,
use <code class="xref py py-class docutils literal notranslate"><span class="pre">FretImageSelector</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sel</span> <span class="o">=</span> <span class="n">FretImageSelector</span><span class="p">(</span><span class="s2">&quot;dddda&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">acc_direct</span> <span class="o">=</span> <span class="n">sel</span><span class="p">(</span><span class="n">acceptor_img</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="tracking">
<h2>Tracking<a class="headerlink" href="#tracking" title="Permalink to this headline">Â¶</a></h2>
<dl class="py class">
<dt id="sdt.fret.SmFretTracker">
<em class="property">class </em><code class="sig-prename descclassname">sdt.fret.</code><code class="sig-name descname">SmFretTracker</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">excitation_seq</span><span class="o">=</span><span class="default_value">'da'</span></em>, <em class="sig-param"><span class="n">chromatic_corr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">link_radius</span><span class="o">=</span><span class="default_value">5</span></em>, <em class="sig-param"><span class="n">link_mem</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">min_length</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">feat_radius</span><span class="o">=</span><span class="default_value">4</span></em>, <em class="sig-param"><span class="n">bg_frame</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="n">bg_estimator</span><span class="o">=</span><span class="default_value">'mean'</span></em>, <em class="sig-param"><span class="n">neighbor_radius</span><span class="o">=</span><span class="default_value">'auto'</span></em>, <em class="sig-param"><span class="n">interpolate</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">coloc_dist</span><span class="o">=</span><span class="default_value">2.0</span></em>, <em class="sig-param"><span class="n">acceptor_channel</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="n">link_quiet</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">link_options</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">columns</span><span class="o">=</span><span class="default_value">{}</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/fret/sm_track.html#SmFretTracker"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.fret.SmFretTracker" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Class for tracking of smFRET data</p>
<p>There is support for dumping and loading to/from YAML using
<code class="xref py py-mod docutils literal notranslate"><span class="pre">sdt.io.yaml</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>excitation_seq</strong> (<em>str or list-like of characters, optional</em>) â Set the <a class="reference internal" href="#sdt.fret.SmFretTracker.excitation_seq" title="sdt.fret.SmFretTracker.excitation_seq"><code class="xref py py-attr docutils literal notranslate"><span class="pre">excitation_seq</span></code></a> attribute. Defaults to âdaâ.</p></li>
<li><p><strong>chromatic_corr</strong> (<em>chromatic.Corrector or None, optional</em>) â Corrector used to overlay channels. If <cite>None</cite>, create a Corrector
with the identity transform. Defaults to <cite>None</cite>.</p></li>
<li><p><strong>link_radius</strong> (<em>float, optional</em>) â Maximum movement of features between frames. See <cite>search_range</cite>
option of <code class="xref py py-func docutils literal notranslate"><span class="pre">trackpy.link_df()</span></code>. Defaults to 5.</p></li>
<li><p><strong>link_mem</strong> (<em>int, optional</em>) â Maximum number of frames for which a feature may not be detected.
See <cite>memory</cite> option of <code class="xref py py-func docutils literal notranslate"><span class="pre">trackpy.link_df()</span></code>. Defaults to 1.</p></li>
<li><p><strong>min_length</strong> (<em>int, optional</em>) â Minimum length of tracks. Defaults to 1.</p></li>
<li><p><strong>feat_radius</strong> (<em>int, optional</em>) â Radius of circle that is a little larger than features. See
<cite>radius</cite> option of <code class="xref py py-func docutils literal notranslate"><span class="pre">brightness.from_raw_image()</span></code>.
Defaults to 4.</p></li>
<li><p><strong>bg_frame</strong> (<em>int, optional</em>) â Size of frame around features for background determination. See
<cite>bg_frame</cite> option of <code class="xref py py-func docutils literal notranslate"><span class="pre">brightness.from_raw_image()</span></code>.
Defaults to 2.</p></li>
<li><p><strong>bg_estimator</strong> (<em>{âmeanâ, âmedianâ}, optional</em>) â Statistic to estimate background. See <cite>bg_estimator</cite> option of
<code class="xref py py-func docutils literal notranslate"><span class="pre">brightness.from_raw_image()</span></code>. Defaults to âmeanâ.</p></li>
<li><p><strong>neighbor_radius</strong> (<em>float or âautoâ</em>) â How far two features may be apart while still being considered
close enough so that one influences the brightness measurement of
the other. This is related to the <cite>radius</cite> option of
<code class="xref py py-func docutils literal notranslate"><span class="pre">brightness.from_raw_image()</span></code>. If âautoâ, use the smallest
value that avoids overlaps. Defaults to âautoâ.</p></li>
<li><p><strong>interpolate</strong> (<em>bool, optional</em>) â Whether to interpolate coordinates of features that have been
missed by the localization algorithm. Defaults to <cite>True</cite>.</p></li>
<li><p><strong>coloc_dist</strong> (<em>float</em>) â After overlaying donor and acceptor channel features, this gives
the maximum distance up to which donor and acceptor signal are
considered to come from the same molecule. Defaults to 2.</p></li>
<li><p><strong>acceptor_channel</strong> (<em>{1, 2}, optional</em>) â Whether the acceptor channel is number 1 or 2 in <cite>chromatic_corr</cite>.
Defaults to 2</p></li>
<li><p><strong>link_options</strong> (<em>dict, optional</em>) â Specify additional options to <code class="xref py py-func docutils literal notranslate"><span class="pre">trackpy.link_df()</span></code>.
âsearch_rangeâ and âmemoryâ will be overwritten by the
<cite>link_radius</cite> and <cite>link_mem</cite> parameters. Defaults to {}.</p></li>
<li><p><strong>link_quiet</strong> (<em>bool, optional</em>) â If <cite>True, call :py:func:`trackpy.quiet</cite>. Defaults to <cite>True</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Other Parameters</dt>
<dd class="field-even"><p><strong>columns</strong> (<em>dict, optional</em>) â Override default column names as defined in
<code class="xref py py-attr docutils literal notranslate"><span class="pre">config.columns</span></code>. Relevant names are <cite>coords</cite>, <cite>time</cite>,
<cite>mass</cite>, <cite>signal</cite>, <cite>bg</cite>, <cite>bg_dev</cite>. This means, if your DataFrame has
coordinate columns âxâ and âzâ and the time column âalt_frameâ, set
<code class="docutils literal notranslate"><span class="pre">columns={&quot;coords&quot;:</span> <span class="pre">[&quot;x&quot;,</span> <span class="pre">&quot;z&quot;],</span> <span class="pre">&quot;time&quot;:</span> <span class="pre">&quot;alt_frame&quot;}</span></code>. This
parameters sets the <a class="reference internal" href="#sdt.fret.SmFretTracker.columns" title="sdt.fret.SmFretTracker.columns"><code class="xref py py-attr docutils literal notranslate"><span class="pre">columns</span></code></a> attribute.</p>
</dd>
</dl>
<dl class="py attribute">
<dt id="sdt.fret.SmFretTracker.frame_selector">
<code class="sig-name descname">frame_selector</code><a class="headerlink" href="#sdt.fret.SmFretTracker.frame_selector" title="Permalink to this definition">Â¶</a></dt>
<dd><p>A <a class="reference internal" href="#sdt.fret.FrameSelector" title="sdt.fret.FrameSelector"><code class="xref py py-class docutils literal notranslate"><span class="pre">FrameSelector</span></code></a> instance with the matching
<a class="reference internal" href="#sdt.fret.SmFretTracker.excitation_seq" title="sdt.fret.SmFretTracker.excitation_seq"><code class="xref py py-attr docutils literal notranslate"><span class="pre">excitation_seq</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sdt.fret.SmFretTracker.chromatic_corr">
<code class="sig-name descname">chromatic_corr</code><a class="headerlink" href="#sdt.fret.SmFretTracker.chromatic_corr" title="Permalink to this definition">Â¶</a></dt>
<dd><p>chromatic.Corrector used to overlay channels</p>
</dd></dl>

<dl class="py attribute">
<dt id="sdt.fret.SmFretTracker.link_options">
<code class="sig-name descname">link_options</code><a class="headerlink" href="#sdt.fret.SmFretTracker.link_options" title="Permalink to this definition">Â¶</a></dt>
<dd><p>dict of options passed to <code class="xref py py-func docutils literal notranslate"><span class="pre">trackpy.link_df()</span></code></p>
</dd></dl>

<dl class="py attribute">
<dt id="sdt.fret.SmFretTracker.min_length">
<code class="sig-name descname">min_length</code><a class="headerlink" href="#sdt.fret.SmFretTracker.min_length" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Minimum length of tracks</p>
</dd></dl>

<dl class="py attribute">
<dt id="sdt.fret.SmFretTracker.brightness_options">
<code class="sig-name descname">brightness_options</code><a class="headerlink" href="#sdt.fret.SmFretTracker.brightness_options" title="Permalink to this definition">Â¶</a></dt>
<dd><p>dict of options passed to <code class="xref py py-func docutils literal notranslate"><span class="pre">brightness.from_raw_image()</span></code>.
Make sure to adjust <a class="reference internal" href="#sdt.fret.SmFretTracker.neighbor_radius" title="sdt.fret.SmFretTracker.neighbor_radius"><code class="xref py py-attr docutils literal notranslate"><span class="pre">neighbor_radius</span></code></a> if you change either the
<cite>mask</cite> or the <cite>radius</cite> option!</p>
</dd></dl>

<dl class="py attribute">
<dt id="sdt.fret.SmFretTracker.interpolate">
<code class="sig-name descname">interpolate</code><a class="headerlink" href="#sdt.fret.SmFretTracker.interpolate" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Whether to interpolate coordinates of features that have been missed
by the localization algorithm.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sdt.fret.SmFretTracker.coloc_dist">
<code class="sig-name descname">coloc_dist</code><a class="headerlink" href="#sdt.fret.SmFretTracker.coloc_dist" title="Permalink to this definition">Â¶</a></dt>
<dd><p>After overlaying donor and acceptor channel features, this gives the
maximum distance up to which donor and acceptor signal are considered
to come from the same molecule.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sdt.fret.SmFretTracker.acceptor_channel">
<code class="sig-name descname">acceptor_channel</code><a class="headerlink" href="#sdt.fret.SmFretTracker.acceptor_channel" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Can be either 1 or 2, depending the acceptor is the first or the
second channel in <a class="reference internal" href="#sdt.fret.SmFretTracker.chromatic_corr" title="sdt.fret.SmFretTracker.chromatic_corr"><code class="xref py py-attr docutils literal notranslate"><span class="pre">chromatic_corr</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sdt.fret.SmFretTracker.columns">
<code class="sig-name descname">columns</code><a class="headerlink" href="#sdt.fret.SmFretTracker.columns" title="Permalink to this definition">Â¶</a></dt>
<dd><p>dict of column names in DataFrames. Defaults are taken from
<code class="xref py py-attr docutils literal notranslate"><span class="pre">config.columns</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sdt.fret.SmFretTracker.neighbor_radius">
<code class="sig-name descname">neighbor_radius</code><a class="headerlink" href="#sdt.fret.SmFretTracker.neighbor_radius" title="Permalink to this definition">Â¶</a></dt>
<dd><p>How far two features may be apart while still being considered close
enough so that one influences the brightness measurement of the other.
This is related to the <cite>radius</cite> option of
<code class="xref py py-func docutils literal notranslate"><span class="pre">brightness.from_raw_image()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="sdt.fret.SmFretTracker.excitation_seq">
<em class="property">property </em><code class="sig-name descname">excitation_seq</code><a class="headerlink" href="#sdt.fret.SmFretTracker.excitation_seq" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Excitation sequence. âdâ stands for donor, âaâ for acceptor,
anything else describes other kinds of frames which are irrelevant for
tracking.</p>
<p>One needs only specify the shortest sequence that is repeated,
i. e. âddddaddddaddddaâ is the same as âddddaâ.</p>
</dd></dl>

<dl class="py method">
<dt id="sdt.fret.SmFretTracker.excitation_frames">
<em class="property">property </em><code class="sig-name descname">excitation_frames</code><a class="headerlink" href="#sdt.fret.SmFretTracker.excitation_frames" title="Permalink to this definition">Â¶</a></dt>
<dd><p>dict mapping the excitation types in <a class="reference internal" href="#sdt.fret.SmFretTracker.excitation_seq" title="sdt.fret.SmFretTracker.excitation_seq"><code class="xref py py-attr docutils literal notranslate"><span class="pre">excitation_seq</span></code></a> to
the corresponding frame numbers (modulo the length of
py:attr:<cite>excitation_seq</cite>).</p>
</dd></dl>

<dl class="py method">
<dt id="sdt.fret.SmFretTracker.track">
<code class="sig-name descname">track</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">donor_img</span></em>, <em class="sig-param"><span class="n">acceptor_img</span></em>, <em class="sig-param"><span class="n">donor_loc</span></em>, <em class="sig-param"><span class="n">acceptor_loc</span></em>, <em class="sig-param"><span class="n">d_mass</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/fret/sm_track.html#SmFretTracker.track"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.fret.SmFretTracker.track" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Track smFRET data</p>
<p>Localization data for both the donor and the acceptor channel is
merged (since a FRET construct has to be visible in at least one
channel) taking into account chromatic aberrations. The merged data
is than linked into trajectories using <code class="xref py py-func docutils literal notranslate"><span class="pre">trackpy.link_df()</span></code>.
For this the <code class="xref py py-mod docutils literal notranslate"><span class="pre">trackpy</span></code> package needs to be installed.
Additionally, the feature brightness is determined for both donor
and acceptor for raw image data using
<code class="xref py py-func docutils literal notranslate"><span class="pre">brightness.from_raw_image()</span></code>. These data are written into a
a <code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code> whose columns have a MultiIndex
containing the âdonorâ and âacceptorâ items in the top level.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul>
<li><p><strong>donor_img, acceptor_img</strong> (<em>list of numpy.ndarray</em>) â Raw image frames for donor and acceptor channel. This need to be
of type <cite>list</cite>, but anything that returns image data when indexed
with a frame number will do.</p></li>
<li><p><strong>donor_loc, acceptor_loc</strong> (<em>pandas.DataFrame</em>) â Localization data for donor and acceptor channel</p></li>
<li><p><strong>d_mass</strong> (<em>bool, optional</em>) â If <cite>True</cite>, get total brightness upon donor excitation by
from the sum of donor and acceptor image. If <cite>False</cite>, the
donor excitation brightness can still be calculated as the sum of
donor and acceptor brightness in <code class="xref py py-meth docutils literal notranslate"><span class="pre">analyze()</span></code>. Defaults to
<cite>False</cite>.</p>
<p>Note: Until <code class="xref py py-mod docutils literal notranslate"><span class="pre">slicerator</span></code> with support for multiple
inputs to pipelines is released, setting this to <cite>True</cite> will load
all of <cite>donor_img</cite> and <cite>acceptor_img</cite> into memory, even if
<code class="xref py py-mod docutils literal notranslate"><span class="pre">pims</span></code> is used.</p>
</li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The columns are indexed with a <code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.MultiIndex</span></code>.
The top index level consists of âdonorâ (tracking data for the
donor channel), âacceptorâ (tracking data for the acceptor
channel), and âfretâ. The latter contains a column with the
particle number (âparticleâ), an indicator (0 / 1) whether there
is a near neighbor (âhas_neighborâ), and an indicator whether the
data point was interpolated (âinterpâ) because it was not in the
localization data in either channel.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas.DataFrame</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="sdt.fret.SmFretTracker.to_yaml">
<em class="property">classmethod </em><code class="sig-name descname">to_yaml</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dumper</span></em>, <em class="sig-param"><span class="n">data</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/fret/sm_track.html#SmFretTracker.to_yaml"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.fret.SmFretTracker.to_yaml" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Dump as YAML</p>
<p>Pass this as the <cite>representer</cite> parameter to
<code class="xref py py-meth docutils literal notranslate"><span class="pre">yaml.Dumper.add_representer()</span></code></p>
</dd></dl>

<dl class="py method">
<dt id="sdt.fret.SmFretTracker.from_yaml">
<em class="property">classmethod </em><code class="sig-name descname">from_yaml</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">loader</span></em>, <em class="sig-param"><span class="n">node</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/fret/sm_track.html#SmFretTracker.from_yaml"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.fret.SmFretTracker.from_yaml" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Construct from YAML</p>
<p>Pass this as the <cite>constructor</cite> parameter to
<code class="xref py py-meth docutils literal notranslate"><span class="pre">yaml.Loader.add_constructor()</span></code></p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="analysis-and-filtering">
<h2>Analysis and Filtering<a class="headerlink" href="#analysis-and-filtering" title="Permalink to this headline">Â¶</a></h2>
<dl class="py class">
<dt id="sdt.fret.SmFretAnalyzer">
<em class="property">class </em><code class="sig-prename descclassname">sdt.fret.</code><code class="sig-name descname">SmFretAnalyzer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tracks</span></em>, <em class="sig-param"><span class="n">excitation_seq</span></em>, <em class="sig-param"><span class="n">cp_detector</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">columns</span><span class="o">=</span><span class="default_value">{}</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/fret/sm_analyzer.html#SmFretAnalyzer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.fret.SmFretAnalyzer" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Class for analyzing and filtering of smFRET data</p>
<p>This provides various analysis and filtering methods which act on the
<a class="reference internal" href="#sdt.fret.SmFretAnalyzer.tracks" title="sdt.fret.SmFretAnalyzer.tracks"><code class="xref py py-attr docutils literal notranslate"><span class="pre">tracks</span></code></a> attribute.</p>
<p>Correction of FRET efficiencies and stoichiometries for donor leakage and
direct acceptor excitation is implemented according to <a class="reference internal" href="#hell2018" id="id1"><span>[Hell2018]</span></a>,
while different detection efficiencies for the different
fluorophores are accounted for as described in <a class="reference internal" href="#macc2010" id="id2"><span>[MacC2010]</span></a> as well
the different excitation efficiencies according to <a class="reference internal" href="#lee2005" id="id3"><span>[Lee2005]</span></a>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul>
<li><p><strong>tracks</strong> (<em>pandas.DataFrame</em>) â smFRET tracking data as produced by <a class="reference internal" href="#sdt.fret.SmFretTracker" title="sdt.fret.SmFretTracker"><code class="xref py py-class docutils literal notranslate"><span class="pre">SmFretTracker</span></code></a> by
running its <a class="reference internal" href="#sdt.fret.SmFretTracker.track" title="sdt.fret.SmFretTracker.track"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SmFretTracker.track()</span></code></a> method.</p></li>
<li><p><strong>excitation_seq</strong> (<em>str or list-like of characters</em>) â Excitation sequence. âdâ stands for donor, âaâ for acceptor,
anything else describes other kinds of frames which are to be
ignored.</p>
<p>One needs only specify the shortest sequence that is repeated,
i. e. âddddaddddaddddaâ is the same as âddddaâ.</p>
</li>
<li><p><strong>cp_detector</strong> (<em>changepoint detector or None, optional</em>) â If <cite>None</cite>, create a <code class="xref py py-class docutils literal notranslate"><span class="pre">changepoint.Pelt</span></code> instance with
<code class="docutils literal notranslate"><span class="pre">model=&quot;l2&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">min_size=1</span></code>, and <code class="docutils literal notranslate"><span class="pre">jump=1</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Other Parameters</dt>
<dd class="field-even"><p><strong>columns</strong> (<em>dict, optional</em>) â Override default column names as defined in
<code class="xref py py-attr docutils literal notranslate"><span class="pre">config.columns</span></code>. Relevant names are <cite>coords</cite> and <cite>time</cite>.
This means, if your DataFrame has
coordinate columns âxâ and âzâ and the time column âalt_frameâ, set
<code class="docutils literal notranslate"><span class="pre">columns={&quot;coords&quot;:</span> <span class="pre">[&quot;x&quot;,</span> <span class="pre">&quot;z&quot;],</span> <span class="pre">&quot;time&quot;:</span> <span class="pre">&quot;alt_frame&quot;}</span></code>. This
parameters sets the <a class="reference internal" href="#sdt.fret.SmFretAnalyzer.columns" title="sdt.fret.SmFretAnalyzer.columns"><code class="xref py py-attr docutils literal notranslate"><span class="pre">columns</span></code></a> attribute.</p>
</dd>
</dl>
<dl class="py attribute">
<dt id="sdt.fret.SmFretAnalyzer.tracks">
<code class="sig-name descname">tracks</code><a class="headerlink" href="#sdt.fret.SmFretAnalyzer.tracks" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Filtered smFRET tracking data</p>
</dd></dl>

<dl class="py attribute">
<dt id="sdt.fret.SmFretAnalyzer.tracks_orig">
<code class="sig-name descname">tracks_orig</code><a class="headerlink" href="#sdt.fret.SmFretAnalyzer.tracks_orig" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Unfiltered (original) smFRET tracking data</p>
</dd></dl>

<dl class="py attribute">
<dt id="sdt.fret.SmFretAnalyzer.cp_detector">
<code class="sig-name descname">cp_detector</code><a class="headerlink" href="#sdt.fret.SmFretAnalyzer.cp_detector" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Changepoint detector class instance used to perform acceptor
bleaching detection.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sdt.fret.SmFretAnalyzer.columns">
<code class="sig-name descname">columns</code><a class="headerlink" href="#sdt.fret.SmFretAnalyzer.columns" title="Permalink to this definition">Â¶</a></dt>
<dd><p>dict of column names in DataFrames. Defaults are taken from
<code class="xref py py-attr docutils literal notranslate"><span class="pre">config.columns</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sdt.fret.SmFretAnalyzer.leakage">
<code class="sig-name descname">leakage</code><a class="headerlink" href="#sdt.fret.SmFretAnalyzer.leakage" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Correction factor for donor leakage into the acceptor channel;
<span class="math notranslate nohighlight">\(\alpha\)</span> in <a class="reference internal" href="#hell2018" id="id4"><span>[Hell2018]</span></a></p>
</dd></dl>

<dl class="py attribute">
<dt id="sdt.fret.SmFretAnalyzer.direct_excitation">
<code class="sig-name descname">direct_excitation</code><a class="headerlink" href="#sdt.fret.SmFretAnalyzer.direct_excitation" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Correction factor for direct acceptor excitation by the donor
laser; <span class="math notranslate nohighlight">\(\delta\)</span> in <a class="reference internal" href="#hell2018" id="id5"><span>[Hell2018]</span></a></p>
</dd></dl>

<dl class="py attribute">
<dt id="sdt.fret.SmFretAnalyzer.detection_eff">
<code class="sig-name descname">detection_eff</code><a class="headerlink" href="#sdt.fret.SmFretAnalyzer.detection_eff" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Correction factor(s) for the detection efficiency difference
beteen donor and acceptor fluorophore; <span class="math notranslate nohighlight">\(\gamma\)</span> in [Hell2018].</p>
<p>Can be a scalar for global correction or a <code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.Series</span></code>
for individual correction. In the latter case, the index is the
particle number and the value is the correction factor.</p>
</dd></dl>

<dl class="py method">
<dt id="sdt.fret.SmFretAnalyzer.excitation_frames">
<em class="property">property </em><code class="sig-name descname">excitation_frames</code><a class="headerlink" href="#sdt.fret.SmFretAnalyzer.excitation_frames" title="Permalink to this definition">Â¶</a></dt>
<dd><p>dict mapping the excitation types in <a class="reference internal" href="#sdt.fret.SmFretAnalyzer.excitation_seq" title="sdt.fret.SmFretAnalyzer.excitation_seq"><code class="xref py py-attr docutils literal notranslate"><span class="pre">excitation_seq</span></code></a> to
the corresponding frame numbers (modulo the length of
py:attr:<cite>excitation_seq</cite>).</p>
</dd></dl>

<dl class="py method">
<dt id="sdt.fret.SmFretAnalyzer.excitation_seq">
<em class="property">property </em><code class="sig-name descname">excitation_seq</code><a class="headerlink" href="#sdt.fret.SmFretAnalyzer.excitation_seq" title="Permalink to this definition">Â¶</a></dt>
<dd><p>pandas.Series of CategoricalDtype describing the excitation
sequence. Typically, âdâ would stand for donor, âaâ for acceptor.</p>
<p>One needs only specify the shortest sequence that is repeated,
i. e. âddddaddddaddddaâ is the same as âddddaâ.</p>
</dd></dl>

<dl class="py method">
<dt id="sdt.fret.SmFretAnalyzer.calc_fret_values">
<code class="sig-name descname">calc_fret_values</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">keep_d_mass</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">invalid_nan</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">a_mass_interp</span><span class="o">=</span><span class="default_value">'linear'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/fret/sm_analyzer.html#SmFretAnalyzer.calc_fret_values"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.fret.SmFretAnalyzer.calc_fret_values" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Calculate FRET-related values</p>
<p>This needs to be called before the filtering methods and before
calculating the true FRET efficiencies and stoichiometries. However,
any corrections to the donor and acceptor localization data (such as
<a class="reference internal" href="#sdt.fret.SmFretAnalyzer.flatfield_correction" title="sdt.fret.SmFretAnalyzer.flatfield_correction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flatfield_correction()</span></code></a>) need to be done before this.</p>
<p>Calculated values apparent FRET efficiencies and stoichiometries,
the total brightness (mass) upon donor excitation, and the acceptor
brightness (mass) upon direct excitation, which is interpolated for
donor excitation datapoints in order to allow for calculation of
stoichiometries.</p>
<p>A column specifying whether the entry originates from donor or
acceptor excitation is also added: (âfretâ, âexc_typeâ). It is âdâ
for donor and âaâ for acceptor excitation; see the
<a class="reference internal" href="#sdt.fret.SmFretAnalyzer.flag_excitation_type" title="sdt.fret.SmFretAnalyzer.flag_excitation_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flag_excitation_type()</span></code></a> method.</p>
<p>For each localization in <cite>tracks</cite>, the total brightness upon donor
excitation is calculated by taking the sum of <code class="docutils literal notranslate"><span class="pre">(&quot;donor&quot;,</span> <span class="pre">&quot;mass&quot;)</span></code>
and <code class="docutils literal notranslate"><span class="pre">(&quot;acceptor&quot;,</span> <span class="pre">&quot;mass&quot;)</span></code> values. It is added as a
<code class="docutils literal notranslate"><span class="pre">(&quot;fret&quot;,</span> <span class="pre">&quot;d_mass&quot;)</span></code> column to the <cite>tracks</cite> DataFrame. The
apparent FRET efficiency (acceptor brightness (mass) divided by sum of
donor and acceptor brightnesses) is added as a
<code class="docutils literal notranslate"><span class="pre">(&quot;fret&quot;,</span> <span class="pre">&quot;eff_app&quot;)</span></code> column to the <cite>tracks</cite> DataFrame.</p>
<p>The apparent stoichiometry value <span class="math notranslate nohighlight">\(S_\text{app}\)</span> is given as</p>
<div class="math notranslate nohighlight">
\[S_\text{app} = \frac{I_{DD} + I_{DA}}{I_{DD} + I_{DA} +
I_{AA}}\]</div>
<p>as in <a class="reference internal" href="#hell2018" id="id6"><span>[Hell2018]</span></a>. <span class="math notranslate nohighlight">\(I_{DD}\)</span> is the donor brightness upon donor
excitation, <span class="math notranslate nohighlight">\(I_{DA}\)</span> is the acceptor brightness upon donor
excitation, and <span class="math notranslate nohighlight">\(I_{AA}\)</span> is the acceptor brightness upon
acceptor excitation. The latter is calculated by interpolation for
frames with donor excitation.</p>
<p><span class="math notranslate nohighlight">\(I_{AA}\)</span> is append as a <code class="docutils literal notranslate"><span class="pre">(&quot;fret&quot;,</span> <span class="pre">&quot;a_mass&quot;)</span></code> column.
The stoichiometry value is added in the <code class="docutils literal notranslate"><span class="pre">(&quot;fret&quot;,</span> <span class="pre">&quot;stoi_app&quot;)</span></code>
column.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tracks</strong> (<em>pandas.DataFrame</em>) â smFRET tracking data as produced by the
<a class="reference internal" href="#sdt.fret.SmFretTracker.track" title="sdt.fret.SmFretTracker.track"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SmFretTracker.track()</span></code></a></p></li>
<li><p><strong>keep_d_mass</strong> (<em>bool, optional</em>) â If a <code class="docutils literal notranslate"><span class="pre">(&quot;fret&quot;,</span> <span class="pre">&quot;d_mass&quot;)</span></code> column is already present in <cite>tracks</cite>,
use that instead of overwriting it with the sum of
<code class="docutils literal notranslate"><span class="pre">(&quot;donor&quot;,</span> <span class="pre">&quot;mass&quot;)</span></code> and <code class="docutils literal notranslate"><span class="pre">(&quot;acceptor&quot;,</span> <span class="pre">&quot;mass&quot;)</span></code> values. Useful
if <code class="xref py py-meth docutils literal notranslate"><span class="pre">track()</span></code> was called with <code class="docutils literal notranslate"><span class="pre">d_mass=True</span></code>.</p></li>
<li><p><strong>invalid_nan</strong> (<em>bool, optional</em>) â If True, all âd_massâ, âeff_appâ, and âstoi_appâ values for
excitation types other than donor excitation are set to NaN, since
the values donât make sense. Defaults to True.</p></li>
<li><p><strong>a_mass_interp</strong> (<em>{âlinearâ, ânearestâ}, optional</em>) â How to interpolate the acceptor mass upon direct excitation in
donor excitation frames. Defaults to âlinearâ.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="sdt.fret.SmFretAnalyzer.flag_excitation_type">
<code class="sig-name descname">flag_excitation_type</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/fret/sm_analyzer.html#SmFretAnalyzer.flag_excitation_type"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.fret.SmFretAnalyzer.flag_excitation_type" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Add a column indicating excitation type (donor/acceptor/â¦)</p>
<p>Add  (âfretâ, âexc_typeâ) column. It is of âcategoryâ type.</p>
</dd></dl>

<dl class="py method">
<dt id="sdt.fret.SmFretAnalyzer.segment_mass">
<code class="sig-name descname">segment_mass</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">channel</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/fret/sm_analyzer.html#SmFretAnalyzer.segment_mass"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.fret.SmFretAnalyzer.segment_mass" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Segment tracks by changepoint detection in brightness</p>
<p>Changepoint detection is run on the donor or acceptor brightness time
trace, depending on the <cite>channels</cite> argument.
This appends py:attr:<cite>tracks</cite> with a <code class="docutils literal notranslate"><span class="pre">(&quot;fret&quot;,</span> <span class="pre">&quot;d_seg&quot;)</span></code> or
<cite>(âfretâ, âa_segâ)`</cite> column for donor or acceptor, resp. For
each localization, this holds the number of the segment it belongs to.</p>
<p><strong>:py:attr:`tracks` will be sorted according to
``(âfretâ, âparticleâ)`` and ``(âdonorâ, self.columns[âtimeâ])`` in the
process.</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>channel</strong> (<em>{âdonorâ, âacceptorâ}</em>) â In which channel to perform changepoint detection</p></li>
<li><p><strong>**kwargs</strong> â Keyword arguments to pass to <a class="reference internal" href="#sdt.fret.SmFretAnalyzer.cp_detector" title="sdt.fret.SmFretAnalyzer.cp_detector"><code class="xref py py-attr docutils literal notranslate"><span class="pre">cp_detector</span></code></a>
<cite>find_changepoints</cite> method.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Pass <code class="docutils literal notranslate"><span class="pre">penalty=1e6</span></code> to the changepoint detectorâs
<code class="docutils literal notranslate"><span class="pre">find_changepoints</span></code> method, perform detection both channels:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ana</span><span class="o">.</span><span class="n">segment_mass</span><span class="p">(</span><span class="s2">&quot;donor&quot;</span><span class="p">,</span> <span class="n">penalty</span><span class="o">=</span><span class="mf">1e6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ana</span><span class="o">.</span><span class="n">segment_mass</span><span class="p">(</span><span class="s2">&quot;acceptor&quot;</span><span class="p">,</span> <span class="n">penalty</span><span class="o">=</span><span class="mf">1e6</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sdt.fret.SmFretAnalyzer.bleach_step">
<code class="sig-name descname">bleach_step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">donor_thresh</span></em>, <em class="sig-param"><span class="n">acceptor_thresh</span></em>, <em class="sig-param"><span class="n">truncate</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/fret/sm_analyzer.html#SmFretAnalyzer.bleach_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.fret.SmFretAnalyzer.bleach_step" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Find tracks wwith acceptable fluorophore bleaching behavior</p>
<p>âAcceptableâ means that the acceptor bleaches to a value less than
<cite>acceptor_thresh</cite> in a single step and the donor shows either no
bleach step or bleaches to a value less than <cite>donor_thresh</cite> in
a single step.</p>
<p>This works under the premise that the acceptor is susceptible to
bleaching and will bleach during recording the movie, while the
donor is more stable and may or may not bleach.</p>
<p>Both the <code class="docutils literal notranslate"><span class="pre">(&quot;fret&quot;,</span> <span class="pre">&quot;d_seg&quot;)</span></code> and the <cite>(âfretâ, âa_segâ)`</cite> need to
be present for this to work, which can be achieved by performing
changepoint detection has to be performed in both channels using
<a class="reference internal" href="#sdt.fret.SmFretAnalyzer.segment_mass" title="sdt.fret.SmFretAnalyzer.segment_mass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">segment_mass()</span></code></a>.</p>
<p>Only if the median brightness for each but the first step is below
<cite>brightness_thresh</cite>, accept the track.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>donor_thresh, acceptor_thresh</strong> (<em>float</em>) â Consider fluorophore bleached if its brightness
(<code class="docutils literal notranslate"><span class="pre">(&quot;fret&quot;,</span> <span class="pre">&quot;d_mass&quot;)</span></code> or <code class="docutils literal notranslate"><span class="pre">(&quot;fret&quot;,</span> <span class="pre">&quot;a_mass&quot;)</span></code>, respectively)
median is below this value.</p></li>
<li><p><strong>truncate</strong> (<em>bool, optional</em>) â If <cite>True</cite>, remove data after the bleach step. Defaults to <cite>True</cite>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Consider acceptors with a brightness <code class="docutils literal notranslate"><span class="pre">(&quot;fret&quot;,</span> <span class="pre">&quot;a_mass&quot;)</span></code> of less
than 500 counts and donors with a brightness <code class="docutils literal notranslate"><span class="pre">(&quot;fret&quot;,</span> <span class="pre">&quot;d_mass&quot;)</span></code> of
less than 800 counts bleached. Remove all tracks that donât show
acceptable bleaching behavior. Of the other tracks, only keep data from
before any bleaching.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">filt</span><span class="o">.</span><span class="n">acceptor_bleach_step</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="n">truncate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sdt.fret.SmFretAnalyzer.eval">
<code class="sig-name descname">eval</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">expr</span></em>, <em class="sig-param"><span class="n">mi_sep</span><span class="o">=</span><span class="default_value">'_'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/fret/sm_analyzer.html#SmFretAnalyzer.eval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.fret.SmFretAnalyzer.eval" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Call <code class="docutils literal notranslate"><span class="pre">eval(expr)</span></code> for <cite>tracks</cite></p>
<p>Flatten the column MultiIndex and call the resulting DataFrameâs
<cite>eval</cite> method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>expr</strong> (<em>str</em>) â Argument for eval. See <code class="xref py py-meth docutils literal notranslate"><span class="pre">pandas.DataFrame.eval()</span></code> for
details.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Boolean Series indicating whether an entry fulfills <cite>expr</cite> or not.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas.Series, dtype(bool)</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Get a boolean array indicating lines where (âfretâ, âa_massâ) &lt;= 500
in <a class="reference internal" href="#sdt.fret.SmFretAnalyzer.tracks" title="sdt.fret.SmFretAnalyzer.tracks"><code class="xref py py-attr docutils literal notranslate"><span class="pre">tracks</span></code></a></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">filt</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s2">&quot;fret_a_mass &gt; 500&quot;</span><span class="p">)</span>
<span class="go">0     True</span>
<span class="go">1     True</span>
<span class="go">2    False</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><p><strong>mi_sep</strong> (<em>str, optional</em>) â Use this to separate levels when flattening the column
MultiIndex. Defaults to â_â.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="sdt.fret.SmFretAnalyzer.query">
<code class="sig-name descname">query</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">expr</span></em>, <em class="sig-param"><span class="n">mi_sep</span><span class="o">=</span><span class="default_value">'_'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/fret/sm_analyzer.html#SmFretAnalyzer.query"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.fret.SmFretAnalyzer.query" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Filter features according to column values</p>
<p>Flatten the column MultiIndex and filter the resulting DataFrameâs
<cite>eval</cite> method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>expr</strong> (<em>str</em>) â Filter expression. See <code class="xref py py-meth docutils literal notranslate"><span class="pre">pandas.DataFrame.eval()</span></code> for
details.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Remove lines where (âfretâ, âa_massâ) &lt;= 500 from <a class="reference internal" href="#sdt.fret.SmFretAnalyzer.tracks" title="sdt.fret.SmFretAnalyzer.tracks"><code class="xref py py-attr docutils literal notranslate"><span class="pre">tracks</span></code></a></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">filt</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;fret_a_mass &gt; 500&quot;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><p><strong>mi_sep</strong> (<em>str, optional</em>) â Use this to separate levels when flattening the column
MultiIndex. Defaults to â_â.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="sdt.fret.SmFretAnalyzer.query_particles">
<code class="sig-name descname">query_particles</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">expr</span></em>, <em class="sig-param"><span class="n">min_abs</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">min_rel</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">mi_sep</span><span class="o">=</span><span class="default_value">'_'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/fret/sm_analyzer.html#SmFretAnalyzer.query_particles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.fret.SmFretAnalyzer.query_particles" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Remove particles that donât fulfill <cite>expr</cite> enough times</p>
<p>Any particle that does not fulfill <cite>expr</cite> at least <cite>min_abs</cite> times AND
during at least a fraction of <cite>min_rel</cite> of its length is removed from
<a class="reference internal" href="#sdt.fret.SmFretAnalyzer.tracks" title="sdt.fret.SmFretAnalyzer.tracks"><code class="xref py py-attr docutils literal notranslate"><span class="pre">tracks</span></code></a>.</p>
<p>The column MultiIndex is flattened for this purpose.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expr</strong> (<em>str</em>) â Filter expression. See <code class="xref py py-meth docutils literal notranslate"><span class="pre">pandas.DataFrame.eval()</span></code> for
details.</p></li>
<li><p><strong>min_abs</strong> (<em>int, optional</em>) â Minimum number of times a particle has to fulfill <cite>expr</cite>. If
negative, this means âall but <code class="docutils literal notranslate"><span class="pre">abs(min_count)</span></code>â. If 0, it has
to be fulfilled in all frames.</p></li>
<li><p><strong>min_rel</strong> (<em>float, optional</em>) â Minimum fraction of data points that have to fulfill <cite>expr</cite> for a
particle not to be removed.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Remove any particles where not (âfretâ, âa_massâ) &gt; 500 at least twice
from <a class="reference internal" href="#sdt.fret.SmFretAnalyzer.tracks" title="sdt.fret.SmFretAnalyzer.tracks"><code class="xref py py-attr docutils literal notranslate"><span class="pre">tracks</span></code></a>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">filt</span><span class="o">.</span><span class="n">filter_particles</span><span class="p">(</span><span class="s2">&quot;fret_a_mass &gt; 500&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Remove any particles where (âfretâ, âa_massâ) &lt;= 500 in more than one
frame:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">filt</span><span class="o">.</span><span class="n">filter_particles</span><span class="p">(</span><span class="s2">&quot;fret_a_mass &gt; 500&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Remove any particle where not (âfretâ, âa_massâ) &gt; 500 for at least
75 % of the particleâs data points, with a minimum of two data points:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">filt</span><span class="o">.</span><span class="n">filter_particles</span><span class="p">(</span><span class="s2">&quot;fret_a_mass &gt; 500&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">min_rel</span><span class="o">=</span><span class="mf">0.75</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><p><strong>mi_sep</strong> (<em>str, optional</em>) â Use this to separate levels when flattening the column
MultiIndex. Defaults to â_â.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="sdt.fret.SmFretAnalyzer.image_mask">
<code class="sig-name descname">image_mask</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mask</span></em>, <em class="sig-param"><span class="n">channel</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/fret/sm_analyzer.html#SmFretAnalyzer.image_mask"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.fret.SmFretAnalyzer.image_mask" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Filter using a boolean mask image</p>
<p>Remove all lines where coordinates lie in a region where <cite>mask</cite> is
<cite>False</cite>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul>
<li><p><strong>mask</strong> (<em>numpy.ndarray, dtype(bool) or list of dict</em>) â Mask image(s). If this is a single array, apply it to the whole
<a class="reference internal" href="#sdt.fret.SmFretAnalyzer.tracks" title="sdt.fret.SmFretAnalyzer.tracks"><code class="xref py py-attr docutils literal notranslate"><span class="pre">tracks</span></code></a> DataFrame.</p>
<p>This can also be a list of dicts, where each dict <code class="docutils literal notranslate"><span class="pre">d</span></code> has to have
a âkeyâ and a âmaskâ (ndarray) entry. Then each <code class="docutils literal notranslate"><span class="pre">d[&quot;mask&quot;]</span></code> is
applied separately to the corresponding
<code class="docutils literal notranslate"><span class="pre">self.tracks.loc[d[&quot;key&quot;]]</span></code>. Additionally, the dicts may also
have âstartâ and âstopâ entries, in which case the mask will be
applied only to datapoints with frames greater or equal <cite>start</cite> and
less than <cite>stop</cite>; all others will be discarded. With this it is
possible to apply multiple masks to the same key depending on the
frame number.</p>
</li>
<li><p><strong>channel</strong> (<em>{âdonorâ, âacceptorâ}</em>) â Channel to use for the filtering</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Create a 2D boolean mask to remove any features that do not have
x and y coordinates between 50 and 100 in the donor channel.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span><span class="p">[</span><span class="mi">50</span><span class="p">:</span><span class="mi">100</span><span class="p">,</span> <span class="mi">50</span><span class="p">:</span><span class="mi">100</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filt</span><span class="o">.</span><span class="n">image_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="s2">&quot;donor&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>If <a class="reference internal" href="#sdt.fret.SmFretAnalyzer.tracks" title="sdt.fret.SmFretAnalyzer.tracks"><code class="xref py py-attr docutils literal notranslate"><span class="pre">tracks</span></code></a> has a MultiIndex index, where e.g. the first
level is âfile1â, âfile2â, â¦ and different masks should be applied
for each file, this is possible by passing a list of
dicts. Furthermore, we can apply one mask to all frames up to 100 and
another to the rest:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">masks</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">masks</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;key&quot;</span><span class="p">:</span> <span class="s2">&quot;file</span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span>
<span class="gp">... </span>                  <span class="s2">&quot;mask&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">10</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">i</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span>
<span class="gp">... </span>                  <span class="s2">&quot;stop&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">masks</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;key&quot;</span><span class="p">:</span> <span class="s2">&quot;file</span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span>
<span class="gp">... </span>                  <span class="s2">&quot;mask&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">20</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">i</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span>
<span class="gp">... </span>                  <span class="s2">&quot;start&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filt</span><span class="o">.</span><span class="n">image_mask</span><span class="p">(</span><span class="n">masks</span><span class="p">,</span> <span class="s2">&quot;donor&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sdt.fret.SmFretAnalyzer.reset">
<code class="sig-name descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/fret/sm_analyzer.html#SmFretAnalyzer.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.fret.SmFretAnalyzer.reset" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Undo any filtering</p>
<p>Reset <a class="reference internal" href="#sdt.fret.SmFretAnalyzer.tracks" title="sdt.fret.SmFretAnalyzer.tracks"><code class="xref py py-attr docutils literal notranslate"><span class="pre">tracks</span></code></a> to the initial state.</p>
</dd></dl>

<dl class="py method">
<dt id="sdt.fret.SmFretAnalyzer.flatfield_correction">
<code class="sig-name descname">flatfield_correction</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">donor_corr</span></em>, <em class="sig-param"><span class="n">acceptor_corr</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/fret/sm_analyzer.html#SmFretAnalyzer.flatfield_correction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.fret.SmFretAnalyzer.flatfield_correction" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Apply flatfield correction to donor and acceptor localization data</p>
<p>This affects only the donor and acceptor âmassâ and âsignalâ columns.
Any values derived from those need to be recalculated manually.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>donor_corr, acceptor_corr</strong> (<em>flatfield.Corrector</em>) â Corrector instances for donor and acceptor channel, respectivey.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="sdt.fret.SmFretAnalyzer.calc_leakage">
<code class="sig-name descname">calc_leakage</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/fret/sm_analyzer.html#SmFretAnalyzer.calc_leakage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.fret.SmFretAnalyzer.calc_leakage" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Calculate donor leakage (bleed-through) into the acceptor channel</p>
<p>For this to work, <a class="reference internal" href="#sdt.fret.SmFretAnalyzer.tracks" title="sdt.fret.SmFretAnalyzer.tracks"><code class="xref py py-attr docutils literal notranslate"><span class="pre">tracks</span></code></a> must be a dataset of donor-only
molecules. In this case, the leakage <span class="math notranslate nohighlight">\(alpha\)</span> can be
computed using the formula <a class="reference internal" href="#hell2018" id="id7"><span>[Hell2018]</span></a></p>
<div class="math notranslate nohighlight">
\[\alpha = \frac{\lange E_\text{app}\rangle}{1 -
\langle E_\text{app}\rangle},\]</div>
<p>where <span class="math notranslate nohighlight">\(\langle E_\text{app}\rangle\)</span> is the mean apparent FRET
efficiency of a donor-only population.</p>
<p>The leakage <span class="math notranslate nohighlight">\(\alpha\)</span> together with the direct acceptor excitation
<span class="math notranslate nohighlight">\(\delta\)</span> can be used to calculate the real fluorescence due to
FRET,</p>
<div class="math notranslate nohighlight">
\[F_\text{DA} = I_\text{DA} - \alpha I_\text{DD} - \delta
I_\text{AA}.\]</div>
<p>This sets the <a class="reference internal" href="#sdt.fret.SmFretAnalyzer.leakage" title="sdt.fret.SmFretAnalyzer.leakage"><code class="xref py py-attr docutils literal notranslate"><span class="pre">leakage</span></code></a> attribute.
See <a class="reference internal" href="#sdt.fret.SmFretAnalyzer.fret_correction" title="sdt.fret.SmFretAnalyzer.fret_correction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fret_correction()</span></code></a> for how use this to calculate corrected
FRET values.</p>
</dd></dl>

<dl class="py method">
<dt id="sdt.fret.SmFretAnalyzer.calc_direct_excitation">
<code class="sig-name descname">calc_direct_excitation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/fret/sm_analyzer.html#SmFretAnalyzer.calc_direct_excitation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.fret.SmFretAnalyzer.calc_direct_excitation" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Calculate direct acceptor excitation by the donor laser</p>
<p>For this to work, <a class="reference internal" href="#sdt.fret.SmFretAnalyzer.tracks" title="sdt.fret.SmFretAnalyzer.tracks"><code class="xref py py-attr docutils literal notranslate"><span class="pre">tracks</span></code></a> must be a dataset of acceptor-only
molecules. In this case, the direct acceptor excitation <span class="math notranslate nohighlight">\(delta\)</span>
can be computed using the formula <a class="reference internal" href="#hell2018" id="id8"><span>[Hell2018]</span></a></p>
<div class="math notranslate nohighlight">
\[\alpha = \frac{\lange S_\text{app}\rangle}{1 -
\langle S_\text{app}\rangle},\]</div>
<p>where <span class="math notranslate nohighlight">\(\langle ES\text{app}\rangle\)</span> is the mean apparent FRET
stoichiometry of an acceptor-only population.</p>
<p>The leakage <span class="math notranslate nohighlight">\(\alpha\)</span> together with the direct acceptor excitation
<span class="math notranslate nohighlight">\(\delta\)</span> can be used to calculate the real fluorescence due to
FRET,</p>
<div class="math notranslate nohighlight">
\[F_\text{DA} = I_\text{DA} - \alpha I_\text{DD} - \delta
I_\text{AA}.\]</div>
<p>This sets the <a class="reference internal" href="#sdt.fret.SmFretAnalyzer.direct_excitation" title="sdt.fret.SmFretAnalyzer.direct_excitation"><code class="xref py py-attr docutils literal notranslate"><span class="pre">direct_excitation</span></code></a> attribute.
See <a class="reference internal" href="#sdt.fret.SmFretAnalyzer.fret_correction" title="sdt.fret.SmFretAnalyzer.fret_correction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fret_correction()</span></code></a> for how use this to calculate corrected
FRET values.</p>
</dd></dl>

<dl class="py method">
<dt id="sdt.fret.SmFretAnalyzer.calc_detection_eff">
<code class="sig-name descname">calc_detection_eff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">min_part_len</span><span class="o">=</span><span class="default_value">5</span></em>, <em class="sig-param"><span class="n">how</span><span class="o">=</span><span class="default_value">'individual'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/fret/sm_analyzer.html#SmFretAnalyzer.calc_detection_eff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.fret.SmFretAnalyzer.calc_detection_eff" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Calculate detection efficiency ratio of dyes</p>
<p>The detection efficiency ratio is the ratio of decrease in acceptor
brightness to the increase in donor brightness upon acceptor
photobleaching <a class="reference internal" href="#macc2010" id="id9"><span>[MacC2010]</span></a>:</p>
<div class="math notranslate nohighlight">
\[\gamma = \frac{\langle I_\text{DA}^\text{pre}\rangle -
\langle I_\text{DA}^\text{post}\rangle}{
\langle I_\text{DD}^\text{post}\rangle -
\langle I_\text{DD}^\text{pre}\rangle}\]</div>
<p>This needs molecules with exactly one donor and one acceptor
fluorophore to work. Tracks need to be segmented already (see
<code class="xref py py-meth docutils literal notranslate"><span class="pre">segment_a_mass()</span></code>).</p>
<p>The correction can be calculated for each track individually or some
statistic (e.g. the median) of the indivdual <span class="math notranslate nohighlight">\(gamma\)</span> values can
be used as a global correction factor for all tracks.</p>
<p>The detection efficiency <span class="math notranslate nohighlight">\(\gamma\)</span> can be used to calculate the
real fluorescence of the donor fluorophore,</p>
<div class="math notranslate nohighlight">
\[F_\text{DD} = \gamma I_\text{DD}.\]</div>
<p>This sets the <a class="reference internal" href="#sdt.fret.SmFretAnalyzer.detection_eff" title="sdt.fret.SmFretAnalyzer.detection_eff"><code class="xref py py-attr docutils literal notranslate"><span class="pre">detection_eff</span></code></a> attribute.
See <a class="reference internal" href="#sdt.fret.SmFretAnalyzer.fret_correction" title="sdt.fret.SmFretAnalyzer.fret_correction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fret_correction()</span></code></a> for how use this to calculate corrected
FRET values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>min_part_len</strong> (<em>int, optional</em>) â How many data points need to be present before and after the
bleach step to ensure a reliable calculation of the mean
intensities. If there are fewer data points, a value of NaN will be
assigned. Defaults to 5.</p></li>
<li><p><strong>how</strong> (<em>âindividualâ or callable, optional</em>) â If âindividualâ, the <span class="math notranslate nohighlight">\(\gamma\)</span> value for each track will be
stored and used to correct the values individually when calling
<a class="reference internal" href="#sdt.fret.SmFretAnalyzer.fret_correction" title="sdt.fret.SmFretAnalyzer.fret_correction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fret_correction()</span></code></a>. If a function, apply this function
to the <span class="math notranslate nohighlight">\(\gamma\)</span> array and its return value as a global
correction factor. A sensible example for such a function would be
<code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.nanmean()</span></code>. Beware that some <span class="math notranslate nohighlight">\(\gamma\)</span> may be
NaN. Defaults to âindividualâ.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="sdt.fret.SmFretAnalyzer.calc_excitation_eff">
<code class="sig-name descname">calc_excitation_eff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n_components</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">component</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/fret/sm_analyzer.html#SmFretAnalyzer.calc_excitation_eff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.fret.SmFretAnalyzer.calc_excitation_eff" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Calculate excitation efficiency ratio of dyes</p>
<p>This is a measure of how efficient the direct acceptor excitation is
compared to the donor excitation. It depends on the fluorophores and
also on the excitation laser intensities.</p>
<p>It can be calculated using the formula <a class="reference internal" href="#lee2005" id="id10"><span>[Lee2005]</span></a></p>
<div class="math notranslate nohighlight">
\[\beta = \frac{1 - \langle S_\gamma \rangle}{
\langle S_\gamma\rangle},\]</div>
<p>where <span class="math notranslate nohighlight">\(S_\gamma\)</span> is calculated like the apparent stoichiometry,
but with the donor and acceptor fluorescence upon donor excitation
already corrected using the leakage, direct excitation, and
detection efficiency factors.</p>
<p>This needs molecules with exactly one donor and one acceptor
fluorophore to work. Tracks need to be segmented already (see
<code class="xref py py-meth docutils literal notranslate"><span class="pre">segment_a_mass()</span></code>). The <a class="reference internal" href="#sdt.fret.SmFretAnalyzer.leakage" title="sdt.fret.SmFretAnalyzer.leakage"><code class="xref py py-attr docutils literal notranslate"><span class="pre">leakage</span></code></a>,
<a class="reference internal" href="#sdt.fret.SmFretAnalyzer.direct_excitation" title="sdt.fret.SmFretAnalyzer.direct_excitation"><code class="xref py py-attr docutils literal notranslate"><span class="pre">direct_excitation</span></code></a>, and <a class="reference internal" href="#sdt.fret.SmFretAnalyzer.detection_eff" title="sdt.fret.SmFretAnalyzer.detection_eff"><code class="xref py py-attr docutils literal notranslate"><span class="pre">detection_eff</span></code></a> attributes
need to be set correctly.</p>
<p>The excitation efficiency <span class="math notranslate nohighlight">\(\beta\)</span> can be used to correct the
acceptor fluorescence upon acceptor excitation,</p>
<div class="math notranslate nohighlight">
\[F_\text{AA} = I_\text{AA} / \beta.\]</div>
<p>This sets the <code class="xref py py-attr docutils literal notranslate"><span class="pre">excitation_eff</span></code> attribute.
See <a class="reference internal" href="#sdt.fret.SmFretAnalyzer.fret_correction" title="sdt.fret.SmFretAnalyzer.fret_correction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fret_correction()</span></code></a> for how use this to calculate corrected
FRET values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_components</strong> (<em>int, optional</em>) â If &gt; 1, perform a Gaussian mixture fit on the 2D apparent
efficiency-vs.-stoichiomtry dataset. This helps to choose only the
correct component with one donor and one acceptor. Defaults to 1.</p></li>
<li><p><strong>component</strong> (<em>int, optional</em>) â If n_components &gt; 1, use this to choos the component number.
Components are ordered according to decreasing mean apparent FRET
efficiency. <a class="reference internal" href="#sdt.fret.gaussian_mixture_split" title="sdt.fret.gaussian_mixture_split"><code class="xref py py-func docutils literal notranslate"><span class="pre">gaussian_mixture_split()</span></code></a> can be used to
check which component is the desired one. Defaults to 0.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="sdt.fret.SmFretAnalyzer.fret_correction">
<code class="sig-name descname">fret_correction</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">invalid_nan</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/fret/sm_analyzer.html#SmFretAnalyzer.fret_correction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.fret.SmFretAnalyzer.fret_correction" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Apply corrections to calculate real FRET-related values</p>
<p>By correcting the measured acceptor and donor intensities upon
donor excitation (<span class="math notranslate nohighlight">\(I_\text{DA}\)</span> and <span class="math notranslate nohighlight">\(I_\text{DD}\)</span>) and
acceptor intensity upon acceptor excitation (<span class="math notranslate nohighlight">\(I_\text{AA}\)</span>) for
donor leakage into the acceptor channel <span class="math notranslate nohighlight">\(\alpha\)</span>, acceptor
excitation by the donor laser <span class="math notranslate nohighlight">\(\delta\)</span>, detection efficiencies
<span class="math notranslate nohighlight">\(\gamma\)</span>, and excitation efficiencies <span class="math notranslate nohighlight">\(\beta\)</span>
using <a class="reference internal" href="#hell2018" id="id11"><span>[Hell2018]</span></a></p>
<div class="math notranslate nohighlight">
\[\begin{split}F_\text{DA} = I_\text{DA} - \alpha I_\text{DD} - \delta
I_\text{AA} \\
F_\text{DD} = \gamma I_\text{DD} \\
F_\text{AA} = I_\text{AA} / \beta\end{split}\]</div>
<p>the real FRET efficiency and stoichiometry values can be calculated:</p>
<div class="math notranslate nohighlight">
\[\begin{split}E = \frac{F_\text{DA}}{F_\text{DA} + F_\text{DD} \\
S =  \frac{F_\text{DA} + F_\text{DD}{F_\text{DA} + F_\text{DD +
F_\text{AA}}\end{split}\]</div>
<p><span class="math notranslate nohighlight">\(F_\text{DA}\)</span> will be appended to <a class="reference internal" href="#sdt.fret.SmFretAnalyzer.tracks" title="sdt.fret.SmFretAnalyzer.tracks"><code class="xref py py-attr docutils literal notranslate"><span class="pre">tracks</span></code></a> as the
(âfretâ, âf_daâ) column; <span class="math notranslate nohighlight">\(F_\text{DD}\)</span> as (âfretâ, âf_ddâ);
<span class="math notranslate nohighlight">\(F_\text{DA}\)</span> as (âfretâ, âf_aaâ); <span class="math notranslate nohighlight">\(E\)</span> as (âfretâ, âeffâ);
and <span class="math notranslate nohighlight">\(S\)</span> as (âfretâ, âstoiâ).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>invalid_nan</strong> (<em>bool, optional</em>) â If True, all âeffâ, and âstoiâ values for excitation
types other than donor excitation are set to NaN, since the values
donât make sense. Defaults to True.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="plotting">
<h2>Plotting<a class="headerlink" href="#plotting" title="Permalink to this headline">Â¶</a></h2>
<dl class="py function">
<dt id="sdt.fret.smfret_scatter">
<code class="sig-prename descclassname">sdt.fret.</code><code class="sig-name descname">smfret_scatter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">track_data</span></em>, <em class="sig-param"><span class="n">xdata</span><span class="o">=</span><span class="default_value">'fret', 'eff'</span></em>, <em class="sig-param"><span class="n">ydata</span><span class="o">=</span><span class="default_value">'fret', 'stoi'</span></em>, <em class="sig-param"><span class="n">frame</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">columns</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="n">size</span><span class="o">=</span><span class="default_value">5</span></em>, <em class="sig-param"><span class="n">xlim</span><span class="o">=</span><span class="default_value">None, None</span></em>, <em class="sig-param"><span class="n">ylim</span><span class="o">=</span><span class="default_value">None, None</span></em>, <em class="sig-param"><span class="n">xlabel</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ylabel</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">scatter_args</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">grid</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">ax</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/fret/sm_plot.html#smfret_scatter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.fret.smfret_scatter" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Make scatter plots of multiple smFRET datasets</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>track_data</strong> (<em>dict of str: pandas.DataFrame</em>) â dict keys are used to identify the smFRET datasets (dict values).
The DataFrames have to have the same format as e.g. produced by
<a class="reference internal" href="#sdt.fret.SmFretTracker" title="sdt.fret.SmFretTracker"><code class="xref py py-class docutils literal notranslate"><span class="pre">SmFretTracker</span></code></a>.</p></li>
<li><p><strong>x_data, y_data</strong> (<em>tuple of str, optional</em>) â Column indices of data to plot on the x (y) axis. Defaults to
<code class="docutils literal notranslate"><span class="pre">(&quot;fret&quot;,</span> <span class="pre">&quot;eff&quot;)</span></code> for <cite>x_data</cite> and <code class="docutils literal notranslate"><span class="pre">(&quot;fret&quot;,</span> <span class="pre">&quot;stoi&quot;)</span></code> for
<cite>y_data</cite>.</p></li>
<li><p><strong>frame</strong> (<em>int or None, optional</em>) â If given, only plot data from a certain frame. Defaults to None.</p></li>
<li><p><strong>columns</strong> (<em>int, optional</em>) â In how many columns to lay out plots. Defaults to 2.</p></li>
<li><p><strong>size</strong> (<em>int, optional</em>) â Size per plot. Defaults to 5.</p></li>
<li><p><strong>xlim, ylim</strong> (<em>tuple of float, optional</em>) â Set x (y) axis limits. Defaults to <code class="docutils literal notranslate"><span class="pre">(None,</span> <span class="pre">None)</span></code>, i.e. automatic
determination.</p></li>
<li><p><strong>xlabel, ylabel</strong> (<em>str or None, optional</em>) â Label for x (y) axis. If <cite>None</cite>, use <cite>x_data</cite> (<cite>y_data</cite>). Defaults to
<cite>None</cite>.</p></li>
<li><p><strong>scatter_args</strong> (<em>dict, optional</em>) â Further arguments to pass as keyword arguments to the scatter function.
Defaults to {}.</p></li>
<li><p><strong>grid</strong> (<em>bool, optional</em>) â Whether to draw a grid in the plots. Defaults to True.</p></li>
<li><p><strong>ax</strong> (<em>array-like of matplotlib.axes.Axes or None, optional</em>) â Axes to use for plotting. If <cite>None</cite>, a new figure with axes is
created. Defaults to <cite>None</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>fig</strong> (<em>matplotlib.figure.Figure</em>) â figure object used for plotting</p></li>
<li><p><strong>ax</strong> (<em>numpy.ndarray of mpl.axes.Axes</em>) â axes objects of the plots</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sdt.fret.smfret_hist">
<code class="sig-prename descclassname">sdt.fret.</code><code class="sig-name descname">smfret_hist</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">track_data</span></em>, <em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">'fret', 'eff'</span></em>, <em class="sig-param"><span class="n">frame</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">columns</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="n">size</span><span class="o">=</span><span class="default_value">5</span></em>, <em class="sig-param"><span class="n">xlim</span><span class="o">=</span><span class="default_value">None, None</span></em>, <em class="sig-param"><span class="n">xlabel</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ylabel</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">group_re</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">hist_args</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">ax</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/fret/sm_plot.html#smfret_hist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.fret.smfret_hist" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Make histogram plots of multiple smFRET datasets</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>track_data</strong> (<em>dict of str: pandas.DataFrame</em>) â dict keys are used to identify the smFRET datasets (dict values).
The DataFrames have to have the same format as e.g. produced by
<a class="reference internal" href="#sdt.fret.SmFretTracker" title="sdt.fret.SmFretTracker"><code class="xref py py-class docutils literal notranslate"><span class="pre">SmFretTracker</span></code></a>.</p></li>
<li><p><strong>data, y_data</strong> (<em>tuple of str, optional</em>) â Column indices of data. Defaults to <code class="docutils literal notranslate"><span class="pre">(&quot;fret&quot;,</span> <span class="pre">&quot;eff&quot;)</span></code>.</p></li>
<li><p><strong>frame</strong> (<em>int or None, optional</em>) â If given, only plot data from a certain frame. Defaults to None.</p></li>
<li><p><strong>columns</strong> (<em>int, optional</em>) â In how many columns to lay out plots. Defaults to 2.</p></li>
<li><p><strong>size</strong> (<em>int, optional</em>) â Size per plot. Defaults to 5.</p></li>
<li><p><strong>xlim</strong> (<em>tuple of float, optional</em>) â Set x axis limits. Defaults to <code class="docutils literal notranslate"><span class="pre">(None,</span> <span class="pre">None)</span></code>, i.e. automatic
determination.</p></li>
<li><p><strong>xlabel, ylabel</strong> (<em>str or None, optional</em>) â Label for x (y) axis. If <cite>None</cite>, use <cite>data</cite> for the x axis and
<code class="docutils literal notranslate"><span class="pre">&quot;#</span> <span class="pre">events&quot;</span></code> on the y axis. Defaults to <cite>None</cite>.</p></li>
<li><p><strong>group_re</strong> (<em>tuple(str, int, int) or None, optional</em>) â The first entry in the tuple should be a regular expression with at
least two groups. Datasets from <cite>track_data</cite> will be plotted in the
same plot if whichever regex group is specified by the second entry in
the tuple is the same. The third entry identifies the label of the
dataset in the plot. If None, do no grouping. Defaults to None.</p></li>
<li><p><strong>hist_args</strong> (<em>dict, optional</em>) â Further arguments to pass as keyword arguments to the histogram
plotting function. Defaults to {}.</p></li>
<li><p><strong>ax</strong> (<em>array-like of matplotlib.axes.Axes or None, optional</em>) â Axes to use for plotting. If <cite>None</cite>, a new figure with axes is
created. Defaults to <cite>None</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>fig</strong> (<em>matplotlib.figure.Figure</em>) â figure object used for plotting</p></li>
<li><p><strong>ax</strong> (<em>numpy.ndarray of mpl.axes.Axes</em>) â axes objects of the plots</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sdt.fret.draw_track">
<code class="sig-prename descclassname">sdt.fret.</code><code class="sig-name descname">draw_track</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tracks</span></em>, <em class="sig-param"><span class="n">track_no</span></em>, <em class="sig-param"><span class="n">donor_img</span></em>, <em class="sig-param"><span class="n">acceptor_img</span></em>, <em class="sig-param"><span class="n">size</span></em>, <em class="sig-param"><span class="n">n_cols</span><span class="o">=</span><span class="default_value">8</span></em>, <em class="sig-param"><span class="n">figure</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">columns</span><span class="o">=</span><span class="default_value">{}</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/fret/sm_plot.html#draw_track"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.fret.draw_track" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Draw donor and acceptor images for a track</p>
<p>For each frame in a track, draw the raw image in the proximity of the
feature localization.</p>
<p>Note: This is rather slow.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tracks</strong> (<em>pandas.DataFrame</em>) â smFRET tracking data as e.g. produced by <a class="reference internal" href="#sdt.fret.SmFretTracker" title="sdt.fret.SmFretTracker"><code class="xref py py-class docutils literal notranslate"><span class="pre">SmFretTracker</span></code></a></p></li>
<li><p><strong>track_no</strong> (<em>int</em>) â Track/particle number</p></li>
<li><p><strong>donor_img, acceptor_img</strong> (<em>list-like of numpy.ndarray</em>) â Image sequences of the donor and acceptor channels</p></li>
<li><p><strong>size</strong> (<em>int</em>) â For each feature, draw a square of <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">size</span> <span class="pre">+</span> <span class="pre">1</span></code> size pixels.</p></li>
<li><p><strong>n_cols</strong> (<em>int, optional</em>) â Arrange images in that many columns. Defaults to 8.</p></li>
<li><p><strong>figure</strong> (<em>matplotlib.figure.Figure or None, optional</em>) â Use this figure to draw. If <cite>None</cite>, use
<code class="xref py py-func docutils literal notranslate"><span class="pre">matplotlib.pyplot.gcf()</span></code>. Defaults to <cite>None</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The figure object used for plotting</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>matplotlib.figure.Figure</p>
</dd>
<dt class="field-even">Other Parameters</dt>
<dd class="field-even"><p><strong>columns</strong> (<em>dict, optional</em>) â Override default column names as defined in
<code class="xref py py-attr docutils literal notranslate"><span class="pre">config.columns</span></code>. The only relevant name is <cite>coords</cite>.
This means, if your DataFrame has coordinate columns âxâ and âzâ, set
<code class="docutils literal notranslate"><span class="pre">columns={&quot;coords&quot;:</span> <span class="pre">[&quot;x&quot;,</span> <span class="pre">&quot;z&quot;]}</span></code>.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="image-selection">
<h2>Image selection<a class="headerlink" href="#image-selection" title="Permalink to this headline">Â¶</a></h2>
<dl class="py class">
<dt id="sdt.fret.FrameSelector">
<em class="property">class </em><code class="sig-prename descclassname">sdt.fret.</code><code class="sig-name descname">FrameSelector</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">excitation_seq</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/fret/utils.html#FrameSelector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.fret.FrameSelector" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Select images of a certain excitation type from an image series</p>
<p>E.g. if employing alternating excitation, this can be used to select only
the donor or only the acceptor frames.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Sequence of 6 &quot;images&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_seq</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sel</span> <span class="o">=</span> <span class="n">FrameSelector</span><span class="p">(</span><span class="s2">&quot;odda&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sel</span><span class="p">(</span><span class="n">img_seq</span><span class="p">,</span> <span class="s2">&quot;o&quot;</span><span class="p">)</span>
<span class="go">array([[[0, 0, 0],</span>
<span class="go">        [0, 0, 0],</span>
<span class="go">        [0, 0, 0]],</span>

<span class="go">       [[4, 4, 4],</span>
<span class="go">        [4, 4, 4],</span>
<span class="go">        [4, 4, 4]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sel</span><span class="p">(</span><span class="n">img_seq</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">)</span>
<span class="go">array([[[1, 1, 1],</span>
<span class="go">        [1, 1, 1],</span>
<span class="go">        [1, 1, 1]],</span>

<span class="go">       [[2, 2, 2],</span>
<span class="go">        [2, 2, 2],</span>
<span class="go">        [2, 2, 2]],</span>

<span class="go">       [[5, 5, 5],</span>
<span class="go">        [5, 5, 5],</span>
<span class="go">        [5, 5, 5]],</span>

<span class="go">       [[6, 6, 6],</span>
<span class="go">        [6, 6, 6],</span>
<span class="go">        [6, 6, 6]]])</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>excitation_seq</strong> (<em>str or list-like of characters</em>) â Excitation sequence. Typically, âdâ would stand for donor, âaâ for
acceptor.</p>
<p>One needs only specify the shortest sequence that is repeated,
i. e. âddddaddddaddddaâ is the same as âddddaâ.</p>
</dd>
</dl>
<dl class="py method">
<dt id="sdt.fret.FrameSelector.excitation_frames">
<em class="property">property </em><code class="sig-name descname">excitation_frames</code><a class="headerlink" href="#sdt.fret.FrameSelector.excitation_frames" title="Permalink to this definition">Â¶</a></dt>
<dd><p>dict mapping the excitation types in <a class="reference internal" href="#sdt.fret.FrameSelector.excitation_seq" title="sdt.fret.FrameSelector.excitation_seq"><code class="xref py py-attr docutils literal notranslate"><span class="pre">excitation_seq</span></code></a> to
the corresponding frame numbers (modulo the length of
py:attr:<cite>excitation_seq</cite>).</p>
</dd></dl>

<dl class="py method">
<dt id="sdt.fret.FrameSelector.excitation_seq">
<em class="property">property </em><code class="sig-name descname">excitation_seq</code><a class="headerlink" href="#sdt.fret.FrameSelector.excitation_seq" title="Permalink to this definition">Â¶</a></dt>
<dd><p>numpy.ndarray of dtype(â&lt;U1â) describing the excitation sequence.
Typically, âdâ would stand for donor, âaâ for
acceptor.</p>
<p>One needs only specify the shortest sequence that is repeated,
i. e. âddddaddddaddddaâ is the same as âddddaâ.</p>
</dd></dl>

<dl class="py method">
<dt id="sdt.fret.FrameSelector.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">which</span><span class="o">=</span><span class="default_value">'d'</span></em>, <em class="sig-param"><span class="n">renumber</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">columns</span><span class="o">=</span><span class="default_value">{}</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/fret/utils.html#FrameSelector.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.fret.FrameSelector.__call__" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get only data corresponding to a certain excitation type</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul>
<li><p><strong>data</strong> (<em>pandas.DataFrame or list-like of numpy.ndarrays</em>) â Localization data or sequence of images</p></li>
<li><p><strong>which</strong> (<em>str or iterable of str, optional</em>) â Excitation type(s). This should match something in
<a class="reference internal" href="#sdt.fret.FrameSelector.excitation_seq" title="sdt.fret.FrameSelector.excitation_seq"><code class="xref py py-attr docutils literal notranslate"><span class="pre">excitation_seq</span></code></a>. Defaults to âdâ.</p></li>
<li><p><strong>renumber</strong> (<em>bool, optional</em>) â Renumber frames so that only frames for excitation types
corresponding to <cite>which</cite> are counted.</p>
<p>After selecting only data corresponding to an excitation type (e.g.
âaâ) in a <code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>, all other types are
missing and frame number are not consecutive any more. This can be
a problem for tracking or diffusion analysis. Setting
<code class="docutils literal notranslate"><span class="pre">renumber=True</span></code> will work around this.</p>
<p>Only applicable if <cite>data</cite> is a <code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>.
Defaults to <cite>False</cite>.</p>
</li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>Selected frames. If <cite>data</cite> is a DataFrame, return only lines
corresponding to excitation types given by <cite>which</cite>. If
<code class="docutils literal notranslate"><span class="pre">renumber=True</span></code>, a modified copy of <cite>data</cite> is returned.</p>
<p>If <cite>data</cite> is an image sequence, first an attempt is made at
indexing the images  directly. If <cite>data</cite> supports this (e.g. if it
is a <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>), the indexed version is returned.
Otherwise, <cite>img_seq</cite> is converted to
<a class="reference internal" href="helper.html#sdt.helper.Slicerator" title="sdt.helper.Slicerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">sdt.helper.Slicerator</span></code></a>, indexed, and returned.</p>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>type(data) or slicerator.Slicerator</p>
</dd>
<dt class="field-even">Other Parameters</dt>
<dd class="field-even"><p><strong>columns</strong> (<em>dict, optional</em>) â Override default column names in case <cite>data</cite> is a
<code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>. The only relevant name is <cite>time</cite>.
That means, if the DataFrame has frame number columns âframe2â,
set <code class="docutils literal notranslate"><span class="pre">columns={&quot;time&quot;:</span> <span class="pre">&quot;frame2&quot;}</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="sdt.fret.FrameSelector.restore_frame_numbers">
<code class="sig-name descname">restore_frame_numbers</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">which</span><span class="o">=</span><span class="default_value">'d'</span></em>, <em class="sig-param"><span class="n">columns</span><span class="o">=</span><span class="default_value">{}</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/fret/utils.html#FrameSelector.restore_frame_numbers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.fret.FrameSelector.restore_frame_numbers" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Undo frame renumbering from <a class="reference internal" href="#sdt.fret.FrameSelector.__call__" title="sdt.fret.FrameSelector.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a></p>
<p><cite>data</cite> is modified in place for this purpose.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>pandas.DataFrame</em>) â Localization data</p></li>
<li><p><strong>which</strong> (<em>str or iterable of str, optional</em>) â Excitation type(s). This should match something in
<a class="reference internal" href="#sdt.fret.FrameSelector.excitation_seq" title="sdt.fret.FrameSelector.excitation_seq"><code class="xref py py-attr docutils literal notranslate"><span class="pre">excitation_seq</span></code></a>. Defaults to âdâ.</p></li>
</ul>
</dd>
<dt class="field-even">Other Parameters</dt>
<dd class="field-even"><p><strong>columns</strong> (<em>dict, optional</em>) â Override default column names in case <cite>data</cite> is a
<code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>. The only relevant name is <cite>time</cite>.
That means, if the DataFrame has frame number columns âframe2â,
set <code class="docutils literal notranslate"><span class="pre">columns={&quot;time&quot;:</span> <span class="pre">&quot;frame2&quot;}</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="helpers">
<h2>Helpers<a class="headerlink" href="#helpers" title="Permalink to this headline">Â¶</a></h2>
<dl class="py function">
<dt id="sdt.fret.numeric_exc_type">
<code class="sig-prename descclassname">sdt.fret.</code><code class="sig-name descname">numeric_exc_type</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">df</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/fret/sm_analyzer.html#numeric_exc_type"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.fret.numeric_exc_type" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Context manager temporarily turning (âfretâ, âexc_typeâ) column to int</p>
<p>This is useful e.g. in <code class="xref py py-func docutils literal notranslate"><span class="pre">helper.split_dataframe()</span></code> so that the
resulting split array does not have <cite>object</cite> dtype due to
(âfretâ, âexc_typeâ) being categorical.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tracks</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;exc_type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">CategoricalDtype(categories=[&#39;a&#39;, &#39;d&#39;], ordered=False)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">numeric_exc_type</span><span class="p">(</span><span class="n">tracks</span><span class="p">)</span> <span class="k">as</span> <span class="n">exc_cats</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">tracks</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;exc_type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype(&#39;int64&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">exc_cats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">&quot;a&quot;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">exc_cats</span></code> is an array that holds old categories. It can be used to find
out which (new) integer corresponds to which category</p>
<p>When leaving the <code class="docutils literal notranslate"><span class="pre">with</span></code> block, the old categorical column is restored.
This works only for the original DataFrame, but not for any copies made
within the block!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>df</strong> (<em>pandas.DataFrame</em>) â Dataframe for which to temporarily use an integer (âfretâ, âexc_typeâ)
column.</p>
</dd>
<dt class="field-even">Yields</dt>
<dd class="field-even"><p><em>pandas.Index</em> â Maps integers to categories</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sdt.fret.gaussian_mixture_split">
<code class="sig-prename descclassname">sdt.fret.</code><code class="sig-name descname">gaussian_mixture_split</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">n_components</span></em>, <em class="sig-param"><span class="n">columns</span><span class="o">=</span><span class="default_value">['fret', 'eff_app', 'fret', 'stoi_app']</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/fret/sm_analyzer.html#gaussian_mixture_split"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.fret.gaussian_mixture_split" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Fit Gaussian mixture model and predict component for each particle</p>
<p>First, all datapoints are used to fit a Gaussian mixture model. Then each
particle is assigned the component in which most of its datapoints lie.</p>
<p>This requires scikit-learn (sklearn).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>pandas.DataFrame</em>) â Single molecule FRET data</p></li>
<li><p><strong>n_components</strong> (<em>int</em>) â Number of components in the mixture</p></li>
<li><p><strong>columns</strong> (<em>list of column names, optional</em>) â Which columns to fit. Defaults to <code class="docutils literal notranslate"><span class="pre">[(&quot;fret&quot;,</span> <span class="pre">&quot;eff_app&quot;),</span>
<span class="pre">(&quot;fret&quot;,</span> <span class="pre">&quot;stoi_app&quot;)]</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Each entry is a list of particle number belonging to the same
mixture component. The components are in descending order w.r.t. their
mean <code class="docutils literal notranslate"><span class="pre">columns[0]</span></code> value.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of lists</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="hell2018"><span class="brackets">Hell2018</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id4">2</a>,<a href="#id5">3</a>,<a href="#id6">4</a>,<a href="#id7">5</a>,<a href="#id8">6</a>,<a href="#id11">7</a>)</span></dt>
<dd><p>Hellenkamp, B. et al.: âPrecision and accuracy of
single-molecule FRET measurementsâa multi-laboratory benchmark studyâ,
Nature methods, Nature Publishing Group, 2018, 15, 669</p>
</dd>
<dt class="label" id="macc2010"><span class="brackets">MacC2010</span><span class="fn-backref">(<a href="#id2">1</a>,<a href="#id9">2</a>)</span></dt>
<dd><p>McCann, J. J. et al.: âOptimizing Methods to Recover Absolute
FRET Efficiency from Immobilized Single Moleculesâ Biophysical Journal,
Elsevier BV, 2010, 99, 961â970</p>
</dd>
<dt class="label" id="lee2005"><span class="brackets">Lee2005</span><span class="fn-backref">(<a href="#id3">1</a>,<a href="#id10">2</a>)</span></dt>
<dd><p>Lee, N. et al.: âAccurate FRET Measurements within Single
Diffusing Biomolecules Using Alternating-Laser Excitationâ, Biophysical
Journal, Elsevier BV, 2005, 88, 2939â2953</p>
</dd>
</dl>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="image.html" class="btn btn-neutral float-right" title="Image filtering and processing" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="spatial.html" class="btn btn-neutral float-left" title="Analyze spatial aspects of data" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015â2018, Lukas Schrangl

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>