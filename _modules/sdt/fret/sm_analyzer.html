<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sdt.fret.sm_analyzer &mdash; sdt-python 17.2 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> sdt-python
          </a>
              <div class="version">
                17.2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../roi.html">Regions of interest (ROIs)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../multicolor.html">Multi-color data analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../motion.html">Diffusion analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../brightness.html">Brightness analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../io.html">Data input/output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changepoint.html">Changepoint detection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../spatial.html">Analyze spatial aspects of data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fret.html">Single molecule FRET analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../image.html">Image filtering and processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../flatfield.html">Flat-field correction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../loc.html">Fluorescent feature localization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../nbui.html">GUIs for the Jupyter notebook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sim.html">Simulation of microscopy-related data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../funcs.html">Special functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../plot.html">Plotting utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../optimize.html">Optimization and fitting algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../helper.html">Helpers for writing new code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../CHANGELOG.html">Change log</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">sdt-python</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>sdt.fret.sm_analyzer</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for sdt.fret.sm_analyzer</h1><div class="highlight"><pre>
<span></span><span class="c1"># SPDX-FileCopyrightText: 2020 Lukas Schrangl &lt;lukas.schrangl@tuwien.ac.at&gt;</span>
<span class="c1">#</span>
<span class="c1"># SPDX-License-Identifier: BSD-3-Clause</span>

<span class="sd">&quot;&quot;&quot;Module containing a class for analyzing and filtering smFRET data&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span>
                    <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interp1d</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">utils</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">flatfield</span><span class="p">,</span> <span class="n">helper</span><span class="p">,</span> <span class="n">changepoint</span><span class="p">,</span> <span class="n">config</span><span class="p">,</span> <span class="n">roi</span>


<div class="viewcode-block" id="gaussian_mixture_split"><a class="viewcode-back" href="../../../fret.html#sdt.fret.gaussian_mixture_split">[docs]</a><span class="k">def</span> <span class="nf">gaussian_mixture_split</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">n_components</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                           <span class="n">columns</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span>
                               <span class="p">(</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;eff_app&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;stoi_app&quot;</span><span class="p">)],</span>
                           <span class="n">random_seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
                           <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Fit Gaussian mixture model and predict component for each particle</span>

<span class="sd">    First, all datapoints are used to fit a Gaussian mixture model. Then each</span>
<span class="sd">    particle is assigned the component in which most of its datapoints lie.</span>

<span class="sd">    This requires scikit-learn (sklearn).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data</span>
<span class="sd">        Single-molecule FRET data</span>
<span class="sd">    n_components</span>
<span class="sd">        Number of components in the mixture</span>
<span class="sd">    columns</span>
<span class="sd">        Which columns to fit.</span>
<span class="sd">    random_seed</span>
<span class="sd">        Seed for the random number generator used to initialize the Gaussian</span>
<span class="sd">        mixture model fit.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Component label for each entry in `data` and mean values for each</span>
<span class="sd">    component, one line per component.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sklearn.mixture</span> <span class="kn">import</span> <span class="n">GaussianMixture</span>

    <span class="n">rs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">columns</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>
    <span class="n">gmm</span> <span class="o">=</span> <span class="n">GaussianMixture</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">rs</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">gmm</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="n">mean_sort_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">gmm</span><span class="o">.</span><span class="n">means_</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">sorter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">mean_sort_idx</span><span class="p">)</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">sorter</span><span class="p">[</span><span class="n">labels</span><span class="p">]</span>  <span class="c1"># sort according to descending mean</span>
    <span class="k">return</span> <span class="n">labels</span><span class="p">,</span> <span class="n">gmm</span><span class="o">.</span><span class="n">means_</span><span class="p">[</span><span class="n">mean_sort_idx</span><span class="p">]</span></div>


<div class="viewcode-block" id="apply_track_filters"><a class="viewcode-back" href="../../../fret.html#sdt.fret.apply_track_filters">[docs]</a><span class="k">def</span> <span class="nf">apply_track_filters</span><span class="p">(</span><span class="n">tracks</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">include_negative</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="n">ignore</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[],</span>
                        <span class="n">ret_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;data&quot;</span>
                        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Apply filters to `tracks`</span>

<span class="sd">    This removes all entries from `tracks` that have been marked</span>
<span class="sd">    as filtered via a ``&quot;filter&quot;`` column.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    include_negative</span>
<span class="sd">        If `False`, include only entries for which all ``&quot;filter&quot;`` column</span>
<span class="sd">        values are zero. If `True`, include also entries with negative</span>
<span class="sd">        ``&quot;filter&quot;`` column values.</span>
<span class="sd">    ignore</span>
<span class="sd">        ``&quot;filter&quot;`` column(s) to ignore when deciding whether to include an</span>
<span class="sd">        entry or not. For instance, setting ``ignore=&quot;bleach_step&quot;`` will not</span>
<span class="sd">        consider the ``(&quot;filter&quot;, &quot;bleach_step&quot;)`` column values.</span>
<span class="sd">    ret_type</span>
<span class="sd">        If ``&quot;data&quot;``, return a copy of `tracks` excluding all entries that</span>
<span class="sd">        have been marked as filtered, i.e., that have a positive (or nonzero,</span>
<span class="sd">        see the `include_negative` parameter) entry in any ``&quot;filter&quot;`` column.</span>
<span class="sd">        If ``&quot;mask&quot;``, return a boolean array indicating whether an entry is to</span>
<span class="sd">        be removed or not</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Copy of `tracks` with all filtered rows removed or corresponding boolean</span>
<span class="sd">    mask.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;filter&quot;</span> <span class="ow">in</span> <span class="n">tracks</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">flt</span> <span class="o">=</span> <span class="n">tracks</span><span class="p">[</span><span class="s2">&quot;filter&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">ignore</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">include_negative</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">flt</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">flt</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tracks</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ret_type</span> <span class="o">==</span> <span class="s2">&quot;data&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tracks</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">mask</span></div>


<div class="viewcode-block" id="SmFRETAnalyzer"><a class="viewcode-back" href="../../../fret.html#sdt.fret.SmFRETAnalyzer">[docs]</a><span class="k">class</span> <span class="nc">SmFRETAnalyzer</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Class for analyzing and filtering of smFRET data</span>

<span class="sd">    This provides various analysis and filtering methods which act on the</span>
<span class="sd">    :py:attr:`tracks` attribute.</span>

<span class="sd">    Correction of FRET efficiencies and stoichiometries for donor leakage and</span>
<span class="sd">    direct acceptor excitation is implemented according to [Hell2018]_,</span>
<span class="sd">    while different detection efficiencies for the different</span>
<span class="sd">    fluorophores are accounted for as described in [MacC2010]_ as well</span>
<span class="sd">    the different excitation efficiencies according to [Lee2005]_.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">bleach_thresh</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">500.0</span><span class="p">,</span> <span class="mf">500.0</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Intensity (mass) thresholds upon donor and acceptor excitation,</span>
<span class="sd">    respecitively, below which a signal is considered bleached. Used for</span>
<span class="sd">    bleaching step analysis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tracks</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span>
    <span class="sd">&quot;&quot;&quot;smFRET tracking data&quot;&quot;&quot;</span>
    <span class="n">cp_detector</span><span class="p">:</span> <span class="n">Any</span>
    <span class="sd">&quot;&quot;&quot;Changepoint detector class instance used to perform bleching step</span>
<span class="sd">    detection.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">leakage</span><span class="p">:</span> <span class="nb">float</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Correction factor for donor leakage into the acceptor channel;</span>
<span class="sd">    :math:`\alpha` in [Hell2018]_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">direct_excitation</span><span class="p">:</span> <span class="nb">float</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Correction factor for direct acceptor excitation by the donor</span>
<span class="sd">    laser; :math:`\delta` in [Hell2018]_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">detection_eff</span><span class="p">:</span> <span class="nb">float</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Correction factor(s) for the detection efficiency difference</span>
<span class="sd">    beteen donor and acceptor fluorophore; :math:`\gamma` in [Hell2018].</span>

<span class="sd">    Can be a scalar for global correction or a :py:class:`pandas.Series`</span>
<span class="sd">    for individual correction. In the latter case, the index is the</span>
<span class="sd">    particle number and the value is the correction factor.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">excitation_eff</span><span class="p">:</span> <span class="nb">float</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Correction factor(s) for the excitation efficiency difference</span>
<span class="sd">    beteen donor and acceptor fluorophore; :math:`\beta` in [Hell2018].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">columns</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="sd">&quot;&quot;&quot;Column names to use in DataFrames. See :py:func:`config.set_columns`</span>
<span class="sd">    for details.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@config</span><span class="o">.</span><span class="n">set_columns</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tracks</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">cp_detector</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">reset_filters</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                 <span class="n">keep_filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[],</span>
                 <span class="n">columns</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tracks</span>
<span class="sd">            smFRET tracking data as produced by :py:class:`SmFRETTracker` by</span>
<span class="sd">            running its :py:meth:`SmFRETTracker.track` method.</span>
<span class="sd">        cp_detector</span>
<span class="sd">            Changepoint detetctor. If `None`, create a</span>
<span class="sd">            :py:class:`changepoint.Pelt` instance with ``model=&quot;l2&quot;``,</span>
<span class="sd">            ``min_size=1``, and ``jump=1``.</span>
<span class="sd">        copy</span>
<span class="sd">            If `True`, copy `tracks` to the :py:attr:`tracks` attribute.</span>
<span class="sd">        reset_filters</span>
<span class="sd">            If `True`, reset filters in :py:attr:`tracks`. See also</span>
<span class="sd">            :py:meth:`reset_filters`.</span>
<span class="sd">        keep_filters</span>
<span class="sd">            Filter columns to keep upon resetting. See also</span>
<span class="sd">            :py:meth:`reset_filters`.</span>

<span class="sd">        Other parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        columns</span>
<span class="sd">            Override default column names as defined in</span>
<span class="sd">            :py:attr:`config.columns`. Relevant names are `coords` and `time`.</span>
<span class="sd">            This means, if your DataFrame has</span>
<span class="sd">            coordinate columns &quot;x&quot; and &quot;z&quot; and the time column &quot;alt_frame&quot;, set</span>
<span class="sd">            ``columns={&quot;coords&quot;: [&quot;x&quot;, &quot;z&quot;], &quot;time&quot;: &quot;alt_frame&quot;}``. This</span>
<span class="sd">            parameters sets the :py:attr:`columns` attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span> <span class="o">=</span> <span class="n">tracks</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="n">tracks</span>
        <span class="k">if</span> <span class="n">reset_filters</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reset_filters</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="n">keep_filters</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cp_detector</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cp_detector</span> <span class="o">=</span> <span class="n">changepoint</span><span class="o">.</span><span class="n">Pelt</span><span class="p">(</span><span class="s2">&quot;l2&quot;</span><span class="p">,</span> <span class="n">min_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cp_detector</span> <span class="o">=</span> <span class="n">cp_detector</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">leakage</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">direct_excitation</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">detection_eff</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">excitation_eff</span> <span class="o">=</span> <span class="mf">1.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_reason_counter</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>

<div class="viewcode-block" id="SmFRETAnalyzer.reset_filters"><a class="viewcode-back" href="../../../fret.html#sdt.fret.SmFRETAnalyzer.reset_filters">[docs]</a>    <span class="k">def</span> <span class="nf">reset_filters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keep</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;Reset filters</span>

<span class="sd">        This drops filter columns from :py:attr:`tracks`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keep</span>
<span class="sd">            Filter column name(s) to keep</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;filter&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keep</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">keep</span> <span class="o">=</span> <span class="p">[</span><span class="n">keep</span><span class="p">]</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_loc_level</span><span class="p">(</span><span class="s2">&quot;filter&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">rm_cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">keep</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;filter&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">rm_cols</span><span class="p">],</span>
                         <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="SmFRETAnalyzer.calc_fret_values"><a class="viewcode-back" href="../../../fret.html#sdt.fret.SmFRETAnalyzer.calc_fret_values">[docs]</a>    <span class="k">def</span> <span class="nf">calc_fret_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keep_d_mass</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                         <span class="n">invalid_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                         <span class="n">a_mass_interp</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;nearest-up&quot;</span><span class="p">,</span>
                         <span class="n">skip_neighbors</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate FRET-related values</span>

<span class="sd">        This needs to be called before the filtering methods and before</span>
<span class="sd">        calculating the true FRET efficiencies and stoichiometries. However,</span>
<span class="sd">        any corrections to the donor and acceptor localization data (such as</span>
<span class="sd">        :py:meth:`flatfield_correction`) need to be done before this.</span>

<span class="sd">        Calculated values apparent FRET efficiencies and stoichiometries,</span>
<span class="sd">        the total brightness (mass) upon donor excitation, and the acceptor</span>
<span class="sd">        brightness (mass) upon direct excitation, which is interpolated for</span>
<span class="sd">        donor excitation datapoints in order to allow for calculation of</span>
<span class="sd">        stoichiometries.</span>

<span class="sd">        For each localization in `tracks`, the total brightness upon donor</span>
<span class="sd">        excitation is calculated by taking the sum of ``(&quot;donor&quot;, &quot;mass&quot;)``</span>
<span class="sd">        and ``(&quot;acceptor&quot;, &quot;mass&quot;)`` values. It is added as a</span>
<span class="sd">        ``(&quot;fret&quot;, &quot;d_mass&quot;)`` column to the `tracks` DataFrame. The</span>
<span class="sd">        apparent FRET efficiency (acceptor brightness (mass) divided by sum of</span>
<span class="sd">        donor and acceptor brightnesses) is added as a</span>
<span class="sd">        ``(&quot;fret&quot;, &quot;eff_app&quot;)`` column to the `tracks` DataFrame.</span>

<span class="sd">        The apparent stoichiometry value :math:`S_\text{app}` is given as</span>

<span class="sd">        .. math:: S_\text{app} = \frac{I_{DD} + I_{DA}}{I_{DD} + I_{DA} +</span>
<span class="sd">            I_{AA}}</span>

<span class="sd">        as in [Hell2018]_. :math:`I_{DD}` is the donor brightness upon donor</span>
<span class="sd">        excitation, :math:`I_{DA}` is the acceptor brightness upon donor</span>
<span class="sd">        excitation, and :math:`I_{AA}` is the acceptor brightness upon</span>
<span class="sd">        acceptor excitation. The latter is calculated by interpolation for</span>
<span class="sd">        frames with donor excitation.</span>

<span class="sd">        :math:`I_{AA}` is append as a ``(&quot;fret&quot;, &quot;a_mass&quot;)`` column.</span>
<span class="sd">        The stoichiometry value is added in the ``(&quot;fret&quot;, &quot;stoi_app&quot;)``</span>
<span class="sd">        column.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keep_d_mass</span>
<span class="sd">            If a ``(&quot;fret&quot;, &quot;d_mass&quot;)`` column is already present in `tracks`,</span>
<span class="sd">            use that instead of overwriting it with the sum of</span>
<span class="sd">            ``(&quot;donor&quot;, &quot;mass&quot;)`` and ``(&quot;acceptor&quot;, &quot;mass&quot;)`` values. Useful</span>
<span class="sd">            if :py:meth:`track` was called with ``d_mass=True``.</span>
<span class="sd">        invalid_nan</span>
<span class="sd">            If True, all &quot;d_mass&quot;, &quot;eff_app&quot;, and &quot;stoi_app&quot; values for</span>
<span class="sd">            excitation types other than donor excitation are set to NaN, since</span>
<span class="sd">            the values don&#39;t make sense.</span>
<span class="sd">        a_mass_interp</span>
<span class="sd">            How to interpolate the acceptor mass upon direct excitation in</span>
<span class="sd">            donor excitation frames. Sensible values are &quot;linear&quot; for linear</span>
<span class="sd">            interpolation; &quot;nearest&quot; to take the value of the closest</span>
<span class="sd">            direct acceptor excitation frame (using the previous frame in case</span>
<span class="sd">            of a tie); &quot;nearest-up&quot;, which is similar to &quot;nearest&quot; but takes</span>
<span class="sd">            the next frame in case of a tie; &quot;next&quot; and &quot;previous&quot; to use the</span>
<span class="sd">            next and previous frames, respectively.</span>
<span class="sd">        skip_neighbors</span>
<span class="sd">            If `True`, skip localizations where ``(&quot;fret&quot;, &quot;has_neighbor&quot;)`` is</span>
<span class="sd">            `True` when interpolating acceptor mass upon direct excitation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tmp_mask_col</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;__tmp__&quot;</span><span class="p">,</span> <span class="s2">&quot;__sdt_mask__&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="o">.</span><span class="n">sort_values</span><span class="p">([(</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;particle&quot;</span><span class="p">),</span>
                                 <span class="p">(</span><span class="s2">&quot;donor&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">])],</span>
                                <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="n">tmp_mask_col</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_filters</span><span class="p">(</span><span class="n">ret_type</span><span class="o">=</span><span class="s2">&quot;mask&quot;</span><span class="p">)</span>

        <span class="c1"># Calculate brightness upon acceptor excitation. This requires</span>
        <span class="c1"># interpolation</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;acceptor&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="s2">&quot;mass&quot;</span><span class="p">]),</span>
                <span class="p">(</span><span class="s2">&quot;donor&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]),</span>
                <span class="p">(</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;exc_type&quot;</span><span class="p">),</span>
                <span class="n">tmp_mask_col</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">skip_neighbors</span> <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;has_neighbor&quot;</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">:</span>
            <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;has_neighbor&quot;</span><span class="p">))</span>
            <span class="n">has_nn</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">has_nn</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">a_mass</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="s2">&quot;a&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;exc_type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">categories</span><span class="p">:</span>
            <span class="c1"># Calculate direct acceptor excitation</span>
            <span class="k">with</span> <span class="n">utils</span><span class="o">.</span><span class="n">numeric_exc_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">)</span> <span class="k">as</span> <span class="n">exc_cats</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">trc_p</span> <span class="ow">in</span> <span class="n">helper</span><span class="o">.</span><span class="n">split_dataframe</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;particle&quot;</span><span class="p">),</span> <span class="n">cols</span><span class="p">,</span>
                        <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;array_list&quot;</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
                    <span class="n">ad_p_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">trc_p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">exc_cats</span> <span class="o">==</span> <span class="s2">&quot;a&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="c1"># Locs without neighbors</span>
                    <span class="k">if</span> <span class="n">has_nn</span><span class="p">:</span>
                        <span class="n">nn_p_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">trc_p</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">nn_p_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">trc_p</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                    <span class="c1"># Only use locs with direct accept ex and no neighbors</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">ad_p_mask</span> <span class="o">&amp;</span> <span class="n">nn_p_mask</span> <span class="o">&amp;</span> <span class="n">trc_p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                    <span class="n">a_direct</span> <span class="o">=</span> <span class="n">trc_p</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a_direct</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># No direct acceptor excitation, cannot do anything</span>
                        <span class="n">a_mass</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">trc_p</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">))</span>
                        <span class="k">continue</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">a_direct</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># Only one direct acceptor excitation; use this value</span>
                        <span class="c1"># for all data points of this particle</span>
                        <span class="n">a_mass</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">trc_p</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">a_direct</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                        <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Enough direct acceptor excitations for interpolation</span>
                        <span class="c1"># Values are sorted.</span>
                        <span class="n">time</span> <span class="o">=</span> <span class="n">trc_p</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span>
                        <span class="n">a_mass_func</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span>
                            <span class="n">time</span><span class="p">,</span> <span class="n">a_direct</span><span class="p">,</span> <span class="n">a_mass_interp</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">fill_value</span><span class="o">=</span><span class="p">(</span><span class="n">a_direct</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a_direct</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                            <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                        <span class="c1"># Calculate (interpolated) mass upon direct acceptor</span>
                        <span class="c1"># excitation</span>
                        <span class="n">a_mass</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a_mass_func</span><span class="p">(</span><span class="n">trc_p</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">a_mass</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">a_mass</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a_mass</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">)</span>

        <span class="c1"># Total mass upon donor excitation</span>
        <span class="k">if</span> <span class="n">keep_d_mass</span> <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;d_mass&quot;</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">:</span>
            <span class="n">d_mass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;d_mass&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d_mass</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="s2">&quot;donor&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="s2">&quot;mass&quot;</span><span class="p">]]</span> <span class="o">+</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="s2">&quot;acceptor&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="s2">&quot;mass&quot;</span><span class="p">]])</span>

        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
            <span class="c1"># ignore divide by zero and 0 / 0</span>
            <span class="c1"># FRET efficiency</span>
            <span class="n">eff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="s2">&quot;acceptor&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="s2">&quot;mass&quot;</span><span class="p">]]</span> <span class="o">/</span> <span class="n">d_mass</span>
            <span class="c1"># FRET stoichiometry</span>
            <span class="n">stoi</span> <span class="o">=</span> <span class="n">d_mass</span> <span class="o">/</span> <span class="p">(</span><span class="n">d_mass</span> <span class="o">+</span> <span class="n">a_mass</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">invalid_nan</span><span class="p">:</span>
            <span class="c1"># For direct acceptor excitation, FRET efficiency and stoichiometry</span>
            <span class="c1"># are not sensible</span>
            <span class="n">nd_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;exc_type&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;d&quot;</span>
            <span class="n">eff</span><span class="p">[</span><span class="n">nd_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
            <span class="n">stoi</span><span class="p">[</span><span class="n">nd_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
            <span class="n">d_mass</span><span class="p">[</span><span class="n">nd_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;eff_app&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">eff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;stoi_app&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stoi</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;d_mass&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d_mass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;a_mass&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">a_mass</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">sortlevel</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">tmp_mask_col</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="SmFRETAnalyzer.apply_filters"><a class="viewcode-back" href="../../../fret.html#sdt.fret.SmFRETAnalyzer.apply_filters">[docs]</a>    <span class="k">def</span> <span class="nf">apply_filters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_negative</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                      <span class="n">ignore</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[],</span>
                      <span class="n">ret_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;data&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Apply filters to :py:attr:`tracks`</span>

<span class="sd">        This removes all entries from :py:attr:`tracks` that have been marked</span>
<span class="sd">        as filtered using e.g. :py:meth:`query`, :py:meth:`query_particle`,</span>
<span class="sd">        :py:meth:`bleach_step`, and :py:meth:`image_mask`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        include_negative</span>
<span class="sd">            If `False`, include only entries for which all ``&quot;filter&quot;`` column</span>
<span class="sd">            values are zero. If `True`, include also entries with negative</span>
<span class="sd">            ``&quot;filter&quot;`` column values.</span>
<span class="sd">        ignore</span>
<span class="sd">            ``&quot;filter&quot;`` column(s) to ignore when deciding whether to include</span>
<span class="sd">            an entry or not. For instance, setting ``ignore=&quot;bleach_step&quot;``</span>
<span class="sd">            will not consider the ``(&quot;filter&quot;, &quot;bleach_step&quot;)`` column values.</span>
<span class="sd">        ret_type</span>
<span class="sd">            If ``&quot;data&quot;``, return a copy of :py:attr:`tracks` excluding all</span>
<span class="sd">            entries that have been marked as filtered, i.e., that have a</span>
<span class="sd">            positive (or nonzero, see the `include_negative` parameter) entry</span>
<span class="sd">            in any ``&quot;filter&quot;`` column.</span>
<span class="sd">            If ``&quot;mask&quot;``, return a boolean array indicating whether an entry</span>
<span class="sd">            is to be removed or not</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Copy of :py:attr:`tracks` with all filtered rows removed or</span>
<span class="sd">        corresponding boolean mask.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">apply_track_filters</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">,</span> <span class="n">include_negative</span><span class="p">,</span> <span class="n">ignore</span><span class="p">,</span>
                                   <span class="n">ret_type</span><span class="p">)</span></div>

<div class="viewcode-block" id="SmFRETAnalyzer.mass_changepoints"><a class="viewcode-back" href="../../../fret.html#sdt.fret.SmFRETAnalyzer.mass_changepoints">[docs]</a>    <span class="k">def</span> <span class="nf">mass_changepoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                          <span class="n">stats</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Callable</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span>
                                       <span class="n">Iterable</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Callable</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span>
                                       <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;median&quot;</span><span class="p">,</span>
                          <span class="n">stat_margin</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                          <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Segment tracks by changepoint detection in brightness time trace</span>

<span class="sd">        Changepoint detection is run on the donor or acceptor brightness</span>
<span class="sd">        (``mass``) time trace, depending on the `channels` argument.</span>
<span class="sd">        This appends py:attr:`tracks` with a ``(&quot;fret&quot;, &quot;d_seg&quot;)`` or</span>
<span class="sd">        `(&quot;fret&quot;, &quot;a_seg&quot;)`` column for donor or acceptor, resp. For</span>
<span class="sd">        each localization, this holds the number of the segment it belongs to.</span>
<span class="sd">        Furthermore, statistics (such as median brightness) can/should be</span>
<span class="sd">        calculated, which can later be used to analyze stepwise bleaching</span>
<span class="sd">        (see :py:meth:`bleach_step`).</span>

<span class="sd">        **:py:attr:`tracks` will be sorted according to</span>
<span class="sd">        ``(&quot;fret&quot;, &quot;particle&quot;)`` and ``(&quot;donor&quot;, self.columns[&quot;time&quot;])`` in the</span>
<span class="sd">        process.**</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        channel</span>
<span class="sd">            In which channel (``&quot;donor&quot;`` or ``&quot;acceptor&quot;``) to perform</span>
<span class="sd">            changepoint detection.</span>
<span class="sd">        stats</span>
<span class="sd">            Statistics to calculate for each track segment. For each entry</span>
<span class="sd">            ``s``, a column named ``&quot;{channel}_seg_{s}&quot;`` is appendend, where</span>
<span class="sd">            ``channel`` is ``d`` for donor and ``a`` for acceptor.</span>
<span class="sd">            ``s`` can be the name of a numpy function or a callable returning</span>
<span class="sd">            a statistic, such as :py:func:`numpy.mean`.</span>
<span class="sd">        stat_margin</span>
<span class="sd">            Number of data points around a changepoint to exclude from</span>
<span class="sd">            statistics calculation. This can prevent bias in the statistics due</span>
<span class="sd">            to recording a bleaching event in progress.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments to pass to :py:attr:`cp_detector`</span>
<span class="sd">            `find_changepoints()` method.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Pass ``penalty=1e6`` to the changepoint detector&#39;s</span>
<span class="sd">        ``find_changepoints`` method, perform detection both channels:</span>

<span class="sd">        &gt;&gt;&gt; ana.mass_changepoints(&quot;donor&quot;, penalty=1e6)</span>
<span class="sd">        &gt;&gt;&gt; ana.mass_changepoints(&quot;acceptor&quot;, penalty=1e6)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">time_col</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;donor&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">])</span>
        <span class="n">tmp_mask_col</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;__tmp__&quot;</span><span class="p">,</span> <span class="s2">&quot;__sdt_mask__&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="o">.</span><span class="n">sort_values</span><span class="p">([(</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;particle&quot;</span><span class="p">),</span> <span class="n">time_col</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="n">tmp_mask_col</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_filters</span><span class="p">(</span><span class="n">ret_type</span><span class="o">=</span><span class="s2">&quot;mask&quot;</span><span class="p">)</span>

        <span class="n">e_type</span> <span class="o">=</span> <span class="n">channel</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">e_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s2">&quot;da&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`channel` has to be </span><span class="se">\&quot;</span><span class="s2">donor</span><span class="se">\&quot;</span><span class="s2"> or </span><span class="se">\&quot;</span><span class="s2">acceptor</span><span class="se">\&quot;</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="n">mass_col</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">e_type</span><span class="si">}</span><span class="s2">_mass&quot;</span>
        <span class="n">seg_col</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">e_type</span><span class="si">}</span><span class="s2">_seg&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="n">callable</span><span class="p">(</span><span class="n">stats</span><span class="p">):</span>
            <span class="n">stats</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats</span><span class="p">]</span>
        <span class="n">stat_funcs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">stat_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">stats</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">stat_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
                <span class="n">stat_funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">st</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">st</span><span class="p">):</span>
                <span class="n">stat_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
                <span class="n">stat_funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stat_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">stat_funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">with</span> <span class="n">utils</span><span class="o">.</span><span class="n">numeric_exc_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">)</span> <span class="k">as</span> <span class="n">exc_cats</span><span class="p">:</span>
            <span class="n">trc_split</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">split_dataframe</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;particle&quot;</span><span class="p">),</span>
                <span class="p">[(</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="n">mass_col</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;exc_type&quot;</span><span class="p">),</span> <span class="n">tmp_mask_col</span><span class="p">],</span>
                <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;array_list&quot;</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">exc_num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">exc_cats</span> <span class="o">==</span> <span class="s2">&quot;d&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">def</span> <span class="nf">cp_func</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp_detector</span><span class="o">.</span><span class="n">find_changepoints</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="n">segments</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">stat_results</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">trc_p</span> <span class="ow">in</span> <span class="n">trc_split</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">trc_p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">trc_p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">exc_num</span><span class="p">)</span>
                <span class="n">seg_p</span><span class="p">,</span> <span class="n">stat_p</span> <span class="o">=</span> <span class="n">changepoint</span><span class="o">.</span><span class="n">segment_stats</span><span class="p">(</span>
                    <span class="n">trc_p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cp_func</span><span class="p">,</span> <span class="n">stat_funcs</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
                    <span class="n">stat_margin</span><span class="o">=</span><span class="n">stat_margin</span><span class="p">,</span> <span class="n">return_len</span><span class="o">=</span><span class="s2">&quot;data&quot;</span><span class="p">)</span>
                <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_p</span><span class="p">)</span>
                <span class="n">stat_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stat_p</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="n">seg_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span>
        <span class="n">stat_results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">stat_results</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">st</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">stat_results</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">stat_names</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">seg_col</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">st</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">tmp_mask_col</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_bleaches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steps</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether there is single-step bleaching</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        steps</span>
<span class="sd">            Intensity values (e.g., mean intensity) for each step</span>
<span class="sd">        channel</span>
<span class="sd">            0 for donor, 1 for acceptor. Used to get bleaching thershold from</span>
<span class="sd">            :py:attr:`bleach_thresh`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `True` if track exhibits single-step bleaching, `False` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span>
                <span class="nb">all</span><span class="p">(</span><span class="n">s</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">bleach_thresh</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">steps</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>

    <span class="k">def</span> <span class="nf">_bleaches_partially</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steps</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span>
                            <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns whether there is partial bleaching</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        steps</span>
<span class="sd">            Intensity values (e.g., mean intensity) for each step</span>
<span class="sd">        channel</span>
<span class="sd">            0 for donor, 1 for acceptor. Used to get bleaching thershold from</span>
<span class="sd">            :py:attr:`bleach_thresh`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `True` if there is a bleaching step that does not go below threshold,</span>
<span class="sd">        `False` if there is no bleaching step or bleaching goes below</span>
<span class="sd">        threshold in a single step.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span>
                <span class="nb">any</span><span class="p">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">bleach_thresh</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">steps</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>

    <span class="k">def</span> <span class="nf">_update_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flt</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">reason</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update a filter column</span>

<span class="sd">        If it does not exist yet, append to :py:attr:`self.tracks`. Otherwise,</span>
<span class="sd">        each entry is updated as follows</span>
<span class="sd">        - If ``-1`` before, use the new value</span>
<span class="sd">        - If ``0`` before, leave at 0 if the new value is 0. Set to the</span>
<span class="sd">          appropriate reason count (i.e., ``1`` if the filter reason is used</span>
<span class="sd">          for the first time, ``2`` if used for the second time, and so on).</span>
<span class="sd">        - If greater than ``0`` before, leave as is.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        flt</span>
<span class="sd">            New filter data, one value per line in :py:attr:`tracks`. ``-1``</span>
<span class="sd">            means no decision about filtering, ``0`` means that the entry</span>
<span class="sd">            is accepted, ``1`` means that the entry is rejected.</span>
<span class="sd">        reason</span>
<span class="sd">            Filtering reason / column name to use.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reason_counter</span><span class="p">[</span><span class="n">reason</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">rc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reason_counter</span><span class="p">[</span><span class="n">reason</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;filter&quot;</span><span class="p">,</span> <span class="n">reason</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="s2">&quot;filter&quot;</span><span class="p">,</span> <span class="n">reason</span><span class="p">]</span> <span class="o">=</span> <span class="n">flt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="s2">&quot;filter&quot;</span><span class="p">,</span> <span class="n">reason</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
            <span class="n">old_good</span> <span class="o">=</span> <span class="n">fr</span> <span class="o">&lt;=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">old_good</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">flt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;filter&quot;</span><span class="p">,</span> <span class="n">reason</span><span class="p">)]</span> <span class="o">=</span> <span class="n">rc</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">old_good</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">flt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;filter&quot;</span><span class="p">,</span> <span class="n">reason</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

<div class="viewcode-block" id="SmFRETAnalyzer.bleach_step"><a class="viewcode-back" href="../../../fret.html#sdt.fret.SmFRETAnalyzer.bleach_step">[docs]</a>    <span class="k">def</span> <span class="nf">bleach_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;donor or acceptor&quot;</span><span class="p">,</span>
                    <span class="n">stat</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;median&quot;</span><span class="p">,</span> <span class="n">reason</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;bleach_step&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find tracks with acceptable fluorophore bleaching behavior</span>

<span class="sd">        What &quot;acceptable&quot; means is specified by the `condition` parameter.</span>

<span class="sd">        ``(&quot;fret&quot;, &quot;d_seg&quot;)``, ``(&quot;fret&quot;, f&quot;d_seg_{stat}&quot;)``, ``(&quot;fret&quot;,</span>
<span class="sd">        &quot;a_seg&quot;)``, and ``(&quot;fret&quot;, f&quot;a_seg_{stat}&quot;)`` (where ``{stat}`` is</span>
<span class="sd">        replaced by the value of the `stat` parameter) columns need to be</span>
<span class="sd">        present in :py:attr:`tracks` for this to work, which can be achieved by</span>
<span class="sd">        performing changepoint in both channels using :py:meth:`segment_mass`.</span>

<span class="sd">        The donor considered bleached if its ``(&quot;fret&quot;, f&quot;d_seg_{stat}&quot;)``</span>
<span class="sd">        is below :py:attr:`bleach_thresh` ``[0]``. The acceptor considered</span>
<span class="sd">        bleached if its ``(&quot;fret&quot;, f&quot;a_seg_{stat}&quot;)`` is below</span>
<span class="sd">        :py:attr:`bleach_thresh` ``[0]``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        condition</span>
<span class="sd">            If ``&quot;donor&quot;``, accept only tracks where the donor bleaches in a</span>
<span class="sd">            single step and the acceptor shows either no bleach step or</span>
<span class="sd">            completely bleaches in a single step.</span>
<span class="sd">            Likewise, ``&quot;acceptor&quot;`` will accept only tracks where the acceptor</span>
<span class="sd">            bleaches fully in one step and the donor shows no partial</span>
<span class="sd">            bleaching.</span>
<span class="sd">            ``donor or acceptor`` requires that one channel bleaches in a</span>
<span class="sd">            single step while the other either also bleaches in one step or not</span>
<span class="sd">            at all (no partial bleaching).</span>
<span class="sd">            If ``&quot;no partial&quot;``, there may be no partial bleaching, but</span>
<span class="sd">            bleaching is not required.</span>
<span class="sd">        stat</span>
<span class="sd">            Statistic to use to determine bleaching steps. Has to be one that</span>
<span class="sd">            was passed to via ``stats`` parameter to</span>
<span class="sd">            :py:meth:`mass_changepoints`.</span>
<span class="sd">        reason</span>
<span class="sd">            Filtering reason / column name to use.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Consider acceptors with a brightness ``(&quot;fret&quot;, &quot;a_mass&quot;)`` of less</span>
<span class="sd">        than 500 counts and donors with a brightness ``(&quot;fret&quot;, &quot;d_mass&quot;)`` of</span>
<span class="sd">        less than 800 counts bleached. Remove all tracks that don&#39;t show</span>
<span class="sd">        acceptable bleaching behavior.</span>

<span class="sd">        &gt;&gt;&gt; ana.bleach_thresh = (800, 500)</span>
<span class="sd">        &gt;&gt;&gt; ana.bleach_step(&quot;donor or acceptor&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">time_col</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;donor&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">])</span>
        <span class="n">trc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="o">.</span><span class="n">sort_values</span><span class="p">([(</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;particle&quot;</span><span class="p">),</span> <span class="n">time_col</span><span class="p">])</span>

        <span class="n">trc_split</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">split_dataframe</span><span class="p">(</span>
            <span class="n">trc</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;particle&quot;</span><span class="p">),</span>
            <span class="p">[(</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;d_seg&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;d_seg_</span><span class="si">{</span><span class="n">stat</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;a_seg&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;a_seg_</span><span class="si">{</span><span class="n">stat</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)],</span>
            <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;array_list&quot;</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">good_p</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">trc_p</span> <span class="ow">in</span> <span class="n">trc_split</span><span class="p">:</span>
            <span class="n">is_good</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">trc_p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">trc_p</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                <span class="c1"># -1 as segment number means that changepoint detection failed</span>
                <span class="k">continue</span>

            <span class="c1"># Get change changepoints upon acceptor exc from segments</span>
            <span class="n">cps_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">trc_p</span><span class="p">[</span><span class="mi">2</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">split_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">trc_p</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">cps_a</span><span class="p">)</span>
            <span class="n">stat_a</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">split_a</span><span class="p">]</span>

            <span class="c1"># Get change changepoints upon donor exc from segments</span>
            <span class="n">cps_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">trc_p</span><span class="p">[</span><span class="mi">0</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">split_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">trc_p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cps_d</span><span class="p">)</span>
            <span class="n">stat_d</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">split_d</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">condition</span> <span class="o">==</span> <span class="s2">&quot;donor&quot;</span><span class="p">:</span>
                <span class="n">is_good</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bleaches</span><span class="p">(</span><span class="n">stat_d</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">_bleaches_partially</span><span class="p">(</span><span class="n">stat_a</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">condition</span> <span class="o">==</span> <span class="s2">&quot;acceptor&quot;</span><span class="p">:</span>
                <span class="n">is_good</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bleaches</span><span class="p">(</span><span class="n">stat_a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">_bleaches_partially</span><span class="p">(</span><span class="n">stat_d</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">condition</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;donor or acceptor&quot;</span><span class="p">,</span> <span class="s2">&quot;acceptor or donor&quot;</span><span class="p">):</span>
                <span class="n">is_good</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_bleaches</span><span class="p">(</span><span class="n">stat_d</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_bleaches_partially</span><span class="p">(</span><span class="n">stat_a</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="ow">or</span>
                           <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bleaches</span><span class="p">(</span><span class="n">stat_a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_bleaches_partially</span><span class="p">(</span><span class="n">stat_d</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
            <span class="k">elif</span> <span class="n">condition</span> <span class="o">==</span> <span class="s2">&quot;no partial&quot;</span><span class="p">:</span>
                <span class="n">is_good</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bleaches_partially</span><span class="p">(</span><span class="n">stat_d</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">_bleaches_partially</span><span class="p">(</span><span class="n">stat_a</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unknown strategy: </span><span class="si">{</span><span class="n">condition</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">is_good</span><span class="p">:</span>
                <span class="n">good_p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="n">filtered</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;particle&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">good_p</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_filter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="o">~</span><span class="n">filtered</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">),</span> <span class="n">reason</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_eval</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">mi_sep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Call ``eval(expr)`` for `data`</span>

<span class="sd">        Flatten the column MultiIndex and call the resulting DataFrame&#39;s</span>
<span class="sd">        `eval` method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data</span>
<span class="sd">            Data frame</span>
<span class="sd">        expr</span>
<span class="sd">            Argument for eval. See :py:meth:`pandas.DataFrame.eval` for</span>
<span class="sd">            details.</span>
<span class="sd">        mi_sep</span>
<span class="sd">            Use this to separate levels when flattening the column</span>
<span class="sd">            MultiIndex. Defaults to &quot;_&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.Series, dtype(bool)</span>
<span class="sd">            Boolean Series indicating whether an entry fulfills `expr` or not.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Get a boolean array indicating lines where (&quot;fret&quot;, &quot;a_mass&quot;) &lt;= 500</span>
<span class="sd">        in :py:attr:`tracks`</span>

<span class="sd">        &gt;&gt;&gt; filt._eval(filt.tracks, &quot;fret_a_mass &gt; 500&quot;)</span>
<span class="sd">        0     True</span>
<span class="sd">        1     True</span>
<span class="sd">        2    False</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="n">old_columns</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">flatten_multiindex</span><span class="p">(</span><span class="n">old_columns</span><span class="p">,</span> <span class="n">mi_sep</span><span class="p">)</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">raise</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">old_columns</span>

        <span class="k">return</span> <span class="n">e</span>

<div class="viewcode-block" id="SmFRETAnalyzer.query"><a class="viewcode-back" href="../../../fret.html#sdt.fret.SmFRETAnalyzer.query">[docs]</a>    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">mi_sep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="n">reason</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;query&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Filter features according to column values</span>

<span class="sd">        Flatten the column MultiIndex and filter the resulting DataFrame&#39;s</span>
<span class="sd">        `eval` method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        expr</span>
<span class="sd">            Filter expression. See :py:meth:`pandas.DataFrame.eval` for</span>
<span class="sd">            details.</span>
<span class="sd">        mi_sep</span>
<span class="sd">            Separate multi-index levels by this character / string.</span>
<span class="sd">        reason</span>
<span class="sd">            Filtering reason / column name to use.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Remove lines where (&quot;fret&quot;, &quot;a_mass&quot;) &lt;= 500 from :py:attr:`tracks`</span>

<span class="sd">        &gt;&gt;&gt; filt.query(&quot;fret_a_mass &gt; 500&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filtered</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">mi_sep</span><span class="p">)</span>
        <span class="n">filtered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="o">~</span><span class="n">filtered</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_filter</span><span class="p">(</span><span class="n">filtered</span><span class="p">,</span> <span class="n">reason</span><span class="p">)</span></div>

<div class="viewcode-block" id="SmFRETAnalyzer.query_particles"><a class="viewcode-back" href="../../../fret.html#sdt.fret.SmFRETAnalyzer.query_particles">[docs]</a>    <span class="k">def</span> <span class="nf">query_particles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">min_abs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="n">min_rel</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">mi_sep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="p">,</span>
                        <span class="n">reason</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;query_p&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove particles that don&#39;t fulfill `expr` enough times</span>

<span class="sd">        Any particle that does not fulfill `expr` at least `min_abs` times AND</span>
<span class="sd">        during at least a fraction of `min_rel` of its length is removed from</span>
<span class="sd">        :py:attr:`tracks`.</span>

<span class="sd">        The column MultiIndex is flattened for this purpose.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        expr</span>
<span class="sd">            Filter expression. See :py:meth:`pandas.DataFrame.eval` for</span>
<span class="sd">            details.</span>
<span class="sd">        min_abs</span>
<span class="sd">            Minimum number of times a particle has to fulfill `expr`. If</span>
<span class="sd">            negative, this means &quot;all but ``abs(min_abs)``&quot;. If 0, it has</span>
<span class="sd">            to be fulfilled in all frames.</span>
<span class="sd">        min_rel</span>
<span class="sd">            Minimum fraction of data points that have to fulfill `expr` for a</span>
<span class="sd">            particle not to be removed.</span>
<span class="sd">        mi_sep</span>
<span class="sd">            Use this to separate levels when flattening the column</span>
<span class="sd">            MultiIndex. Defaults to &quot;_&quot;.</span>
<span class="sd">        reason</span>
<span class="sd">            Filtering reason / column name to use.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Remove any particles where not (&quot;fret&quot;, &quot;a_mass&quot;) &gt; 500 at least twice</span>
<span class="sd">        from :py:attr:`tracks`.</span>

<span class="sd">        &gt;&gt;&gt; filt.query_particles(&quot;fret_a_mass &gt; 500&quot;, 2)</span>

<span class="sd">        Remove any particles where (&quot;fret&quot;, &quot;a_mass&quot;) &lt;= 500 in more than one</span>
<span class="sd">        frame:</span>

<span class="sd">        &gt;&gt;&gt; filt.query_particles(&quot;fret_a_mass &gt; 500&quot;, -1)</span>

<span class="sd">        Remove any particle where not (&quot;fret&quot;, &quot;a_mass&quot;) &gt; 500 for at least</span>
<span class="sd">        75 % of the particle&#39;s data points, with a minimum of two data points:</span>

<span class="sd">        &gt;&gt;&gt; filt.query_particles(&quot;fret_a_mass &gt; 500&quot;, 2, min_rel=0.75)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pre_filtered</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_filters</span><span class="p">()</span>
        <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval</span><span class="p">(</span><span class="n">pre_filtered</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">mi_sep</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">all_p</span> <span class="o">=</span> <span class="n">pre_filtered</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;particle&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">p</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">all_p</span><span class="p">[</span><span class="n">e</span><span class="p">],</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">p_sel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">min_abs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">min_abs</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">pre_filtered</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">pre_filtered</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;particle&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">p</span><span class="p">),</span>
                                      <span class="p">(</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;particle&quot;</span><span class="p">)]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
                <span class="n">min_abs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">min_abs</span>
            <span class="n">p_sel</span> <span class="o">&amp;=</span> <span class="n">c</span> <span class="o">&gt;=</span> <span class="n">min_abs</span>
        <span class="k">if</span> <span class="n">min_rel</span><span class="p">:</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">pre_filtered</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">pre_filtered</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;particle&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">p</span><span class="p">),</span>
                                  <span class="p">(</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;particle&quot;</span><span class="p">)]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">p_sel</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">c</span> <span class="o">/</span> <span class="n">c2</span> <span class="o">&gt;=</span> <span class="n">min_rel</span><span class="p">)</span>

        <span class="n">good_p</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">p_sel</span><span class="p">]</span>
        <span class="n">bad_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">all_p</span><span class="p">,</span> <span class="n">good_p</span><span class="p">)</span>

        <span class="n">good</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;particle&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">good_p</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">bad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;particle&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">bad_p</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">flt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
        <span class="n">flt</span><span class="p">[</span><span class="n">good</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">flt</span><span class="p">[</span><span class="n">bad</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_filter</span><span class="p">(</span><span class="n">flt</span><span class="p">,</span> <span class="n">reason</span><span class="p">)</span></div>

<div class="viewcode-block" id="SmFRETAnalyzer.image_mask"><a class="viewcode-back" href="../../../fret.html#sdt.fret.SmFRETAnalyzer.image_mask">[docs]</a>    <span class="k">def</span> <span class="nf">image_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]],</span>
                   <span class="n">channel</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">reason</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;image_mask&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Filter using a boolean mask image</span>

<span class="sd">        Remove all lines where coordinates lie in a region where `mask` is</span>
<span class="sd">        `False`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mask</span>
<span class="sd">            Mask image(s). If this is a single array, apply it to the whole</span>
<span class="sd">            :py:attr:`tracks` DataFrame.</span>

<span class="sd">            This can also be a list of dicts, where each dict ``d`` has to have</span>
<span class="sd">            a &quot;key&quot; and a &quot;mask&quot; (ndarray) entry. Then each ``d[&quot;mask&quot;]`` is</span>
<span class="sd">            applied separately to the corresponding</span>
<span class="sd">            ``self.tracks.loc[d[&quot;key&quot;]]``. Additionally, the dicts may also</span>
<span class="sd">            have &quot;start&quot; and &quot;stop&quot; entries, in which case the mask will be</span>
<span class="sd">            applied only to datapoints with frames greater or equal `start` and</span>
<span class="sd">            less than `stop`; all others will be discarded. With this it is</span>
<span class="sd">            possible to apply multiple masks to the same key depending on the</span>
<span class="sd">            frame number.</span>
<span class="sd">        channel</span>
<span class="sd">            Channel to use for the filtering</span>
<span class="sd">        reason</span>
<span class="sd">            Filtering reason / column name to use.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a 2D boolean mask to remove any features that do not have</span>
<span class="sd">        x and y coordinates between 50 and 100 in the donor channel.</span>

<span class="sd">        &gt;&gt;&gt; mask = numpy.zeros((200, 200), dtype=bool)</span>
<span class="sd">        &gt;&gt;&gt; mask[50:100, 50:100] = True</span>
<span class="sd">        &gt;&gt;&gt; filt.image_mask(mask, &quot;donor&quot;)</span>

<span class="sd">        If :py:attr:`tracks` has a MultiIndex index, where e.g. the first</span>
<span class="sd">        level is &quot;file1&quot;, &quot;file2&quot;,  and different masks should be applied</span>
<span class="sd">        for each file, this is possible by passing a list of</span>
<span class="sd">        dicts. Furthermore, we can apply one mask to all frames up to 100 and</span>
<span class="sd">        another to the rest:</span>

<span class="sd">        &gt;&gt;&gt; masks = []</span>
<span class="sd">        &gt;&gt;&gt; for i in range(1, 10):</span>
<span class="sd">        &gt;&gt;&gt;     masks.append({&quot;key&quot;: &quot;file%i&quot; % i,</span>
<span class="sd">        ...                   &quot;mask&quot;: numpy.ones((10 * i, 10 * i), dtype=bool),</span>
<span class="sd">        ...                   &quot;stop&quot;: 100})</span>
<span class="sd">        &gt;&gt;&gt;     masks.append({&quot;key&quot;: &quot;file%i&quot; % i,</span>
<span class="sd">        ...                   &quot;mask&quot;: numpy.ones((20 * i, 20 * i), dtype=bool),</span>
<span class="sd">        ...                   &quot;start&quot;: 100})</span>
<span class="sd">        &gt;&gt;&gt; filt.image_mask(masks, &quot;donor&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;coords&quot;</span><span class="p">:</span> <span class="p">[(</span><span class="n">channel</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="s2">&quot;coords&quot;</span><span class="p">]]}</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">roi</span><span class="o">.</span><span class="n">MaskROI</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="n">filtered</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">dataframe_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">cols</span><span class="p">)</span>
            <span class="n">filtered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="o">~</span><span class="n">filtered</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">filtered</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">),</span>
                                 <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mask</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">roi</span><span class="o">.</span><span class="n">MaskROI</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="s2">&quot;mask&quot;</span><span class="p">])</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">]</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">cur</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="c1"># No tracking data for the current image</span>
                    <span class="k">continue</span>

                <span class="n">filt</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">dataframe_mask</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">cols</span><span class="p">)</span>
                <span class="n">filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="o">~</span><span class="n">filt</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

                <span class="n">t_col</span> <span class="o">=</span> <span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">])</span>
                <span class="n">t_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;start&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">t_mask</span><span class="p">[</span><span class="n">cur</span><span class="p">[</span><span class="n">t_col</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;stop&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">t_mask</span><span class="p">[</span><span class="n">cur</span><span class="p">[</span><span class="n">t_col</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">stop</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="n">fk</span> <span class="o">=</span> <span class="n">filtered</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">fk</span><span class="p">[</span><span class="n">t_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="n">t_mask</span><span class="p">],</span> <span class="n">fk</span><span class="p">[</span><span class="n">t_mask</span><span class="p">])</span>
                <span class="n">filtered</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">fk</span>
            <span class="n">filtered</span> <span class="o">=</span> <span class="n">filtered</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_filter</span><span class="p">(</span><span class="n">filtered</span><span class="p">,</span> <span class="n">reason</span><span class="p">)</span></div>

<div class="viewcode-block" id="SmFRETAnalyzer.flatfield_correction"><a class="viewcode-back" href="../../../fret.html#sdt.fret.SmFRETAnalyzer.flatfield_correction">[docs]</a>    <span class="k">def</span> <span class="nf">flatfield_correction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">donor_corr</span><span class="p">:</span> <span class="n">flatfield</span><span class="o">.</span><span class="n">Corrector</span><span class="p">,</span>
                             <span class="n">acceptor_corr</span><span class="p">:</span> <span class="n">flatfield</span><span class="o">.</span><span class="n">Corrector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply flatfield correction to donor and acceptor localization data</span>

<span class="sd">        If present, donor and acceptor ``f&quot;{self.columns[&#39;mass&#39;]}_pre_flat&quot;``</span>
<span class="sd">        and ``f&quot;{self.columns[&#39;signal&#39;]}_pre_flat&quot;`` columns are used as inputs</span>
<span class="sd">        for flatfield correction, results are written to</span>
<span class="sd">        ``self.columns[&quot;mass&quot;]`` and `self.columns[&quot;signal&quot;]``.</span>
<span class="sd">        Otherwise, ``self.columns[&quot;mass&quot;]`` and `self.columns[&quot;signal&quot;]`` are</span>
<span class="sd">        copied to ``f&quot;{self.columns[&#39;mass&#39;]}_pre_flat&quot;``</span>
<span class="sd">        and ``f&quot;{self.columns[&#39;signal&#39;]}_pre_flat&quot;`` first.</span>

<span class="sd">        Any values derived from those (e.g., apparent FRET efficiencies) need</span>
<span class="sd">        to be recalculated manually.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        donor_corr, acceptor_corr</span>
<span class="sd">            Corrector instances for donor and acceptor channel, respectivey.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dest_cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span>
            <span class="p">(</span><span class="s2">&quot;donor&quot;</span><span class="p">,</span> <span class="s2">&quot;acceptor&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="s2">&quot;mass&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="s2">&quot;signal&quot;</span><span class="p">])))</span>
        <span class="n">src_cols</span> <span class="o">=</span> <span class="p">[(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">_pre_flat&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">dest_cols</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">src</span><span class="p">,</span> <span class="n">dest</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">src_cols</span><span class="p">,</span> <span class="n">dest_cols</span><span class="p">):</span>
            <span class="c1"># If source columns (i.e., &quot;{col}_pre_flat&quot;) do not exist, create</span>
            <span class="c1"># them</span>
            <span class="k">if</span> <span class="n">src</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="n">dest</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">chan</span><span class="p">,</span> <span class="n">corr</span> <span class="ow">in</span> <span class="p">((</span><span class="s2">&quot;donor&quot;</span><span class="p">,</span> <span class="n">donor_corr</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;acceptor&quot;</span><span class="p">,</span> <span class="n">acceptor_corr</span><span class="p">)):</span>
            <span class="n">typ</span> <span class="o">=</span> <span class="n">chan</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">coord_cols</span> <span class="o">=</span> <span class="p">[(</span><span class="n">chan</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="s2">&quot;coords&quot;</span><span class="p">]]</span>

            <span class="n">sel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;exc_type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">typ</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">corr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="n">sel</span><span class="p">],</span>
                     <span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;coords&quot;</span><span class="p">:</span> <span class="n">coord_cols</span><span class="p">,</span> <span class="s2">&quot;corr&quot;</span><span class="p">:</span> <span class="n">src_cols</span><span class="p">})</span>
            <span class="k">for</span> <span class="n">src</span><span class="p">,</span> <span class="n">dest</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">src_cols</span><span class="p">,</span> <span class="n">dest_cols</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sel</span><span class="p">,</span> <span class="n">dest</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">src</span><span class="p">]</span></div>

<div class="viewcode-block" id="SmFRETAnalyzer.calc_leakage"><a class="viewcode-back" href="../../../fret.html#sdt.fret.SmFRETAnalyzer.calc_leakage">[docs]</a>    <span class="k">def</span> <span class="nf">calc_leakage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate donor leakage (bleed-through) into the acceptor channel</span>

<span class="sd">        For this to work, :py:attr:`tracks` must be a dataset of donor-only</span>
<span class="sd">        molecules. In this case, the leakage :math:`alpha` can be</span>
<span class="sd">        computed using the formula [Hell2018]_</span>

<span class="sd">        .. math:: \alpha = \frac{\langle E_\text{app}\rangle}{1 -</span>
<span class="sd">            \langle E_\text{app}\rangle},</span>

<span class="sd">        where :math:`\langle E_\text{app}\rangle` is the mean apparent FRET</span>
<span class="sd">        efficiency of a donor-only population.</span>

<span class="sd">        The leakage :math:`\alpha` together with the direct acceptor excitation</span>
<span class="sd">        :math:`\delta` can be used to calculate the real fluorescence due to</span>
<span class="sd">        FRET,</span>

<span class="sd">        .. math:: F_\text{DA} = I_\text{DA} - \alpha I_\text{DD} - \delta</span>
<span class="sd">            I_\text{AA}.</span>

<span class="sd">        This sets the :py:attr:`leakage` attribute.</span>
<span class="sd">        See :py:meth:`fret_correction` for how use this to calculate corrected</span>
<span class="sd">        FRET values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_filters</span><span class="p">()</span>
        <span class="n">sel</span> <span class="o">=</span> <span class="p">((</span><span class="n">trc</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;exc_type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;d&quot;</span><span class="p">)</span> <span class="o">&amp;</span>
               <span class="p">(</span><span class="n">trc</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;has_neighbor&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">m_eff</span> <span class="o">=</span> <span class="n">trc</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sel</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;eff_app&quot;</span><span class="p">)]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">leakage</span> <span class="o">=</span> <span class="n">m_eff</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">m_eff</span><span class="p">)</span></div>

<div class="viewcode-block" id="SmFRETAnalyzer.calc_direct_excitation"><a class="viewcode-back" href="../../../fret.html#sdt.fret.SmFRETAnalyzer.calc_direct_excitation">[docs]</a>    <span class="k">def</span> <span class="nf">calc_direct_excitation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate direct acceptor excitation by the donor laser</span>

<span class="sd">        For this to work, :py:attr:`tracks` must be a dataset of acceptor-only</span>
<span class="sd">        molecules. In this case, the direct acceptor excitation :math:`delta`</span>
<span class="sd">        can be computed using the formula [Hell2018]_</span>

<span class="sd">        .. math:: \alpha = \frac{\langle S_\text{app}\rangle}{1 -</span>
<span class="sd">            \langle S_\text{app}\rangle},</span>

<span class="sd">        where :math:`\langle ES\text{app}\rangle` is the mean apparent FRET</span>
<span class="sd">        stoichiometry of an acceptor-only population.</span>

<span class="sd">        The leakage :math:`\alpha` together with the direct acceptor excitation</span>
<span class="sd">        :math:`\delta` can be used to calculate the real fluorescence due to</span>
<span class="sd">        FRET,</span>

<span class="sd">        .. math:: F_\text{DA} = I_\text{DA} - \alpha I_\text{DD} - \delta</span>
<span class="sd">            I_\text{AA}.</span>

<span class="sd">        This sets the :py:attr:`direct_excitation` attribute.</span>
<span class="sd">        See :py:meth:`fret_correction` for how use this to calculate corrected</span>
<span class="sd">        FRET values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_filters</span><span class="p">()</span>
        <span class="n">sel</span> <span class="o">=</span> <span class="p">((</span><span class="n">trc</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;exc_type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;d&quot;</span><span class="p">)</span> <span class="o">&amp;</span>
               <span class="p">(</span><span class="n">trc</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;has_neighbor&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">m_stoi</span> <span class="o">=</span> <span class="n">trc</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sel</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;stoi_app&quot;</span><span class="p">)]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">direct_excitation</span> <span class="o">=</span> <span class="n">m_stoi</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">m_stoi</span><span class="p">)</span></div>

<div class="viewcode-block" id="SmFRETAnalyzer.calc_detection_eff"><a class="viewcode-back" href="../../../fret.html#sdt.fret.SmFRETAnalyzer.calc_detection_eff">[docs]</a>    <span class="k">def</span> <span class="nf">calc_detection_eff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_seg_len</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
                           <span class="n">how</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Callable</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">,</span>
                           <span class="n">stat</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Callable</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate detection efficiency ratio of dyes</span>

<span class="sd">        The detection efficiency ratio is the ratio of decrease in acceptor</span>
<span class="sd">        brightness to the increase in donor brightness upon acceptor</span>
<span class="sd">        photobleaching [MacC2010]_:</span>

<span class="sd">        .. math:: \gamma = \frac{\langle I_\text{DA}^\text{pre}\rangle -</span>
<span class="sd">            \langle I_\text{DA}^\text{post}\rangle}{</span>
<span class="sd">            \langle I_\text{DD}^\text{post}\rangle -</span>
<span class="sd">            \langle I_\text{DD}^\text{pre}\rangle}</span>

<span class="sd">        This needs molecules with exactly one donor and one acceptor</span>
<span class="sd">        fluorophore to work. Tracks need to be segmented already (see</span>
<span class="sd">        :py:meth:`segment_a_mass`).</span>

<span class="sd">        The correction can be calculated for each track individually or some</span>
<span class="sd">        statistic (e.g. the median) of the indivdual :math:`gamma` values can</span>
<span class="sd">        be used as a global correction factor for all tracks.</span>

<span class="sd">        The detection efficiency :math:`\gamma` can be used to calculate the</span>
<span class="sd">        real fluorescence of the donor fluorophore,</span>

<span class="sd">        .. math:: F_\text{DD} = \gamma I_\text{DD}.</span>

<span class="sd">        This sets the :py:attr:`detection_eff` attribute.</span>
<span class="sd">        See :py:meth:`fret_correction` for how use this to calculate corrected</span>
<span class="sd">        FRET values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        min_seg_len</span>
<span class="sd">            How many data points need to be present before and after the</span>
<span class="sd">            bleach step to ensure a reliable calculation of the mean</span>
<span class="sd">            intensities. If there are fewer data points, a value of NaN will be</span>
<span class="sd">            assigned.</span>
<span class="sd">        how</span>
<span class="sd">            If &quot;individual&quot;, the :math:`\gamma` value for each track will be</span>
<span class="sd">            stored and used to correct the values individually when calling</span>
<span class="sd">            :py:meth:`fret_correction`. If a function, apply this function</span>
<span class="sd">            to the :math:`\gamma` array and its return value as a global</span>
<span class="sd">            correction factor. A sensible example for such a function would be</span>
<span class="sd">            :py:func:`numpy.nanmean`. Beware that some :math:`\gamma` may be</span>
<span class="sd">            NaN.</span>
<span class="sd">        stat</span>
<span class="sd">            Statistic to use to determine bleaching steps. If a string, it has</span>
<span class="sd">            to be the name of a function from :py:mod:`numpy`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_filters</span><span class="p">()</span>
        <span class="n">sel</span> <span class="o">=</span> <span class="p">((</span><span class="n">trc</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;exc_type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;d&quot;</span><span class="p">)</span> <span class="o">&amp;</span>
               <span class="p">(</span><span class="n">trc</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;has_neighbor&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">trc</span> <span class="o">=</span> <span class="n">trc</span><span class="p">[</span><span class="n">sel</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span>
            <span class="p">[(</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;particle&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;donor&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">])])</span>
        <span class="n">trc_split</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">split_dataframe</span><span class="p">(</span>
            <span class="n">trc</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;particle&quot;</span><span class="p">),</span>
            <span class="p">[(</span><span class="s2">&quot;donor&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="s2">&quot;mass&quot;</span><span class="p">]),</span>
             <span class="p">(</span><span class="s2">&quot;acceptor&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="s2">&quot;mass&quot;</span><span class="p">]),</span> <span class="p">(</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;a_seg&quot;</span><span class="p">)],</span>
            <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;array_list&quot;</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stat</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">stat</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">stat</span><span class="p">)</span>

        <span class="n">gammas</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">trc_split</span><span class="p">:</span>
            <span class="n">fin_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">pre_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">fin_mask</span>
            <span class="n">post_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">fin_mask</span>

            <span class="n">i_dd_pre</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">pre_mask</span><span class="p">]</span>
            <span class="n">i_dd_post</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">post_mask</span><span class="p">]</span>
            <span class="n">i_da_pre</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">pre_mask</span><span class="p">]</span>
            <span class="n">i_da_post</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">post_mask</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_dd_pre</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_seg_len</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_dd_post</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_seg_len</span><span class="p">:</span>
                <span class="n">gammas</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
                <span class="k">continue</span>

            <span class="n">gammas</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">stat</span><span class="p">(</span><span class="n">i_da_pre</span><span class="p">)</span> <span class="o">-</span> <span class="n">stat</span><span class="p">(</span><span class="n">i_da_post</span><span class="p">))</span> <span class="o">/</span>
                         <span class="p">(</span><span class="n">stat</span><span class="p">(</span><span class="n">i_dd_post</span><span class="p">)</span> <span class="o">-</span> <span class="n">stat</span><span class="p">(</span><span class="n">i_dd_pre</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;individual&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">detection_eff</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">gammas</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">how</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">detection_eff</span> <span class="o">=</span> <span class="n">how</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">gammas</span><span class="o">.</span><span class="n">values</span><span class="p">())))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`how` must be </span><span class="se">\&quot;</span><span class="s2">individual</span><span class="se">\&quot;</span><span class="s2"> or a function &quot;</span>
                             <span class="s2">&quot;accepting an array as its argument.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SmFRETAnalyzer.calc_excitation_eff"><a class="viewcode-back" href="../../../fret.html#sdt.fret.SmFRETAnalyzer.calc_excitation_eff">[docs]</a>    <span class="k">def</span> <span class="nf">calc_excitation_eff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_components</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">component</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                            <span class="n">random_seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate excitation efficiency ratio of dyes</span>

<span class="sd">        This is a measure of how efficient the direct acceptor excitation is</span>
<span class="sd">        compared to the donor excitation. It depends on the fluorophores and</span>
<span class="sd">        also on the excitation laser intensities.</span>

<span class="sd">        It can be calculated using the formula [Lee2005]_</span>

<span class="sd">        .. math:: \beta = \frac{1 - \langle S_\gamma \rangle}{</span>
<span class="sd">            \langle S_\gamma\rangle},</span>

<span class="sd">        where :math:`S_\gamma` is calculated like the apparent stoichiometry,</span>
<span class="sd">        but with the donor and acceptor fluorescence upon donor excitation</span>
<span class="sd">        already corrected using the leakage, direct excitation, and</span>
<span class="sd">        detection efficiency factors.</span>

<span class="sd">        This needs molecules with exactly one donor and one acceptor</span>
<span class="sd">        fluorophore to work. Tracks need to be segmented already (see</span>
<span class="sd">        :py:meth:`segment_a_mass`). The :py:attr:`leakage`,</span>
<span class="sd">        :py:attr:`direct_excitation`, and :py:attr:`detection_eff` attributes</span>
<span class="sd">        need to be set correctly.</span>

<span class="sd">        The excitation efficiency :math:`\beta` can be used to correct the</span>
<span class="sd">        acceptor fluorescence upon acceptor excitation,</span>

<span class="sd">        .. math:: F_\text{AA} = I_\text{AA} / \beta.</span>

<span class="sd">        This sets the :py:attr:`excitation_eff` attribute.</span>
<span class="sd">        See :py:meth:`fret_correction` for how use this to calculate corrected</span>
<span class="sd">        FRET values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_components</span>
<span class="sd">            If &gt; 1, perform a Gaussian mixture fit on the 2D apparent</span>
<span class="sd">            efficiency-vs.-stoichiomtry dataset. This helps to choose only the</span>
<span class="sd">            correct component with one donor and one acceptor. Defaults to 1.</span>
<span class="sd">        component</span>
<span class="sd">            If n_components &gt; 1, use this to choos the component number.</span>
<span class="sd">            Components are ordered according to decreasing mean apparent FRET</span>
<span class="sd">            efficiency. :py:func:`gaussian_mixture_split` can be used to</span>
<span class="sd">            check which component is the desired one. Defaults to 0.</span>
<span class="sd">        random_seed</span>
<span class="sd">            Seed for the random number generator used to initialize the</span>
<span class="sd">            Gaussian mixture model fit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_filters</span><span class="p">()</span>
        <span class="n">trc</span> <span class="o">=</span> <span class="n">trc</span><span class="p">[(</span><span class="n">trc</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;exc_type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;d&quot;</span><span class="p">)</span> <span class="o">&amp;</span>
                  <span class="p">(</span><span class="n">trc</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;a_seg&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span>
                  <span class="p">(</span><span class="n">trc</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;d_seg&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">n_components</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">split</span> <span class="o">=</span> <span class="n">gaussian_mixture_split</span><span class="p">(</span><span class="n">trc</span><span class="p">,</span> <span class="n">n_components</span><span class="p">,</span>
                                           <span class="n">random_seed</span><span class="o">=</span><span class="n">random_seed</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">trc</span> <span class="o">=</span> <span class="n">trc</span><span class="p">[</span><span class="n">split</span> <span class="o">==</span> <span class="n">component</span><span class="p">]</span>

        <span class="n">tmp_ana</span> <span class="o">=</span> <span class="n">SmFRETAnalyzer</span><span class="p">(</span><span class="n">trc</span><span class="p">)</span>
        <span class="n">tmp_ana</span><span class="o">.</span><span class="n">leakage</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leakage</span>
        <span class="n">tmp_ana</span><span class="o">.</span><span class="n">direct_excitation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direct_excitation</span>
        <span class="n">tmp_ana</span><span class="o">.</span><span class="n">detection_eff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">detection_eff</span>
        <span class="n">tmp_ana</span><span class="o">.</span><span class="n">fret_correction</span><span class="p">()</span>

        <span class="n">s_gamma</span> <span class="o">=</span> <span class="n">trc</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;stoi&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">excitation_eff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">s_gamma</span><span class="p">)</span> <span class="o">/</span> <span class="n">s_gamma</span></div>

<div class="viewcode-block" id="SmFRETAnalyzer.calc_detection_excitation_effs"><a class="viewcode-back" href="../../../fret.html#sdt.fret.SmFRETAnalyzer.calc_detection_excitation_effs">[docs]</a>    <span class="k">def</span> <span class="nf">calc_detection_excitation_effs</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">n_components</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
            <span class="n">components</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">random_seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get detection and excitation efficiency from multi-state sample</span>

<span class="sd">        States are found in efficiency-vs.-stoichiometry space using a</span>
<span class="sd">        Gaussian mixture fit. Detection efficiency factor :math:`\gamma` and</span>
<span class="sd">        excitation efficiency factor :math:`\delta` are found performing a</span>
<span class="sd">        linear fit to the equation</span>

<span class="sd">        .. math:: S^{-1} = 1 + \beta\gamma + (1 - \gamma)\beta E</span>

<span class="sd">        to the Gaussian mixture fit results, where :math:`S` are the</span>
<span class="sd">        components&#39; mean stoichiometries (corrected for leakage and direct</span>
<span class="sd">        excitation) and :math:`E` are the corresponding FRET efficiencies</span>
<span class="sd">        (also corrected for leakage and direct excitation) [Hell2018]_.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_components</span>
<span class="sd">            Number of components for Gaussian mixture model</span>
<span class="sd">        components</span>
<span class="sd">            List of indices of components to use for the linear fit. If `None`,</span>
<span class="sd">            use all.</span>
<span class="sd">        random_seed</span>
<span class="sd">            Seed for the random number generator used to initialize the</span>
<span class="sd">            Gaussian mixture model fit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_filters</span><span class="p">()</span>

        <span class="n">tmp_ana</span> <span class="o">=</span> <span class="n">SmFRETAnalyzer</span><span class="p">(</span><span class="n">trc</span><span class="p">)</span>
        <span class="n">tmp_ana</span><span class="o">.</span><span class="n">leakage</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leakage</span>
        <span class="n">tmp_ana</span><span class="o">.</span><span class="n">direct_excitation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direct_excitation</span>
        <span class="n">tmp_ana</span><span class="o">.</span><span class="n">fret_correction</span><span class="p">()</span>

        <span class="n">trc</span> <span class="o">=</span> <span class="n">trc</span><span class="p">[(</span><span class="n">trc</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;exc_type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;d&quot;</span><span class="p">)</span> <span class="o">&amp;</span>
                  <span class="p">(</span><span class="n">trc</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;a_seg&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span>
                  <span class="p">(</span><span class="n">trc</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;d_seg&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]</span>

        <span class="n">split</span> <span class="o">=</span> <span class="n">gaussian_mixture_split</span><span class="p">(</span>
            <span class="n">trc</span><span class="p">,</span> <span class="n">n_components</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;eff&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;stoi&quot;</span><span class="p">)],</span>
            <span class="n">random_seed</span><span class="o">=</span><span class="n">random_seed</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">components</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">components</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">split</span><span class="p">[</span><span class="n">components</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">split</span><span class="p">[</span><span class="n">components</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                          <span class="n">deg</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">detection_eff</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">excitation_eff</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="SmFRETAnalyzer.fret_correction"><a class="viewcode-back" href="../../../fret.html#sdt.fret.SmFRETAnalyzer.fret_correction">[docs]</a>    <span class="k">def</span> <span class="nf">fret_correction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">invalid_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Apply corrections to calculate real FRET-related values</span>

<span class="sd">        By correcting the measured acceptor and donor intensities upon</span>
<span class="sd">        donor excitation (:math:`I_\text{DA}` and :math:`I_\text{DD}`) and</span>
<span class="sd">        acceptor intensity upon acceptor excitation (:math:`I_\text{AA}`) for</span>
<span class="sd">        donor leakage into the acceptor channel :math:`\alpha`, acceptor</span>
<span class="sd">        excitation by the donor laser :math:`\delta`, detection efficiencies</span>
<span class="sd">        :math:`\gamma`, and excitation efficiencies :math:`\beta`</span>
<span class="sd">        using [Hell2018]_</span>

<span class="sd">        .. math:: F_\text{DA} &amp;= I_\text{DA} - \alpha I_\text{DD} - \delta</span>
<span class="sd">            I_\text{AA} \\</span>
<span class="sd">            F_\text{DD} &amp;= \gamma I_\text{DD} \\</span>
<span class="sd">            F_\text{AA} &amp;= I_\text{AA} / \beta</span>

<span class="sd">        the real FRET efficiency and stoichiometry values can be calculated:</span>

<span class="sd">        .. math:: E &amp;= \frac{F_\text{DA}}{F_\text{DA} + F_\text{DD}} \\</span>
<span class="sd">            S &amp;=  \frac{F_\text{DA} + F_\text{DD}}{F_\text{DA} + F_\text{DD} +</span>
<span class="sd">            F_\text{AA}}</span>

<span class="sd">        :math:`F_\text{DA}` will be appended to :py:attr:`tracks` as the</span>
<span class="sd">        ``(&quot;fret&quot;, &quot;f_da&quot;)`` column; :math:`F_\text{DD}` as</span>
<span class="sd">        ``(&quot;fret&quot;, &quot;f_dd&quot;)``; :math:`F_\text{DA}` as ``(&quot;fret&quot;, &quot;f_aa&quot;)``;</span>
<span class="sd">        :math:`E` as ``(&quot;fret&quot;, &quot;eff&quot;)``; and :math:`S` as ``(&quot;fret&quot;,</span>
<span class="sd">        &quot;stoi&quot;)``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        invalid_nan</span>
<span class="sd">            If True, all &quot;eff&quot;, and &quot;stoi&quot; values for excitation</span>
<span class="sd">            types other than donor excitation are set to NaN, since the values</span>
<span class="sd">            don&#39;t make sense. Defaults to True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">detection_eff</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
            <span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">detection_eff</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;particle&quot;</span><span class="p">])</span>
            <span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">detection_eff</span>

        <span class="n">i_da</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="s2">&quot;acceptor&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="s2">&quot;mass&quot;</span><span class="p">]]</span>
        <span class="n">i_dd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="s2">&quot;donor&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="s2">&quot;mass&quot;</span><span class="p">]]</span>
        <span class="n">i_aa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;a_mass&quot;</span><span class="p">]</span>

        <span class="n">f_da</span> <span class="o">=</span> <span class="n">i_da</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">leakage</span> <span class="o">*</span> <span class="n">i_dd</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">direct_excitation</span> <span class="o">*</span> <span class="n">i_aa</span>
        <span class="n">f_dd</span> <span class="o">=</span> <span class="n">i_dd</span> <span class="o">*</span> <span class="n">gamma</span>
        <span class="n">f_aa</span> <span class="o">=</span> <span class="n">i_aa</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">excitation_eff</span>

        <span class="k">if</span> <span class="n">invalid_nan</span><span class="p">:</span>
            <span class="n">sel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;exc_type&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;d&quot;</span>
            <span class="n">f_da</span><span class="p">[</span><span class="n">sel</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
            <span class="n">f_dd</span><span class="p">[</span><span class="n">sel</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;f_da&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">f_da</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;f_dd&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">f_dd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;f_aa&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">f_aa</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;eff&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">f_da</span> <span class="o">/</span> <span class="p">(</span><span class="n">f_dd</span> <span class="o">+</span> <span class="n">f_da</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="s2">&quot;fret&quot;</span><span class="p">,</span> <span class="s2">&quot;stoi&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f_dd</span> <span class="o">+</span> <span class="n">f_da</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">f_dd</span> <span class="o">+</span> <span class="n">f_da</span> <span class="o">+</span> <span class="n">f_aa</span><span class="p">)</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 20152018, Lukas Schrangl.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>