

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Overlay color channels &mdash; sdt-python 15.0 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Multi-color data analysis" href="multicolor.html" />
    <link rel="prev" title="Regions of interest (ROIs)" href="roi.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> sdt-python
          

          
          </a>

          
            
            
              <div class="version">
                15.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="roi.html">Regions of interest (ROIs)</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Overlay color channels</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#programming-reference">Programming reference</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="multicolor.html">Multi-color data analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="motion.html">Diffusion analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="brightness.html">Brightness analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="io.html">Data input/output</a></li>
<li class="toctree-l1"><a class="reference internal" href="changepoint.html">Changepoint detection</a></li>
<li class="toctree-l1"><a class="reference internal" href="spatial.html">Analyze spatial aspects of data</a></li>
<li class="toctree-l1"><a class="reference internal" href="fret.html">Single molecule FRET analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="image.html">Image filtering and processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="flatfield.html">Flat-field correction</a></li>
<li class="toctree-l1"><a class="reference internal" href="loc.html">Fluorescent feature localization</a></li>
<li class="toctree-l1"><a class="reference internal" href="nbui.html">GUIs for the Jupyter notebook</a></li>
<li class="toctree-l1"><a class="reference internal" href="sim.html">Simulation of microscopy-related data</a></li>
<li class="toctree-l1"><a class="reference internal" href="funcs.html">Special functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="plot.html">Plotting utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="optimize.html">Optimization and fitting algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="helper.html">Helpers for writing new code</a></li>
<li class="toctree-l1"><a class="reference internal" href="CHANGELOG.html">Change log</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">sdt-python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Overlay color channels</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <span class="target" id="module-sdt.channel_reg"></span><div class="section" id="overlay-color-channels">
<h1>Overlay color channels<a class="headerlink" href="#overlay-color-channels" title="Permalink to this headline">¶</a></h1>
<p>Multi-color microscopy images are typically created by directing the light of
different wavelengths onto different regions of the camera chip or onto
different cameras.</p>
<p>In order to overlay the different channels, one can record images of
multi-color beads and identify each bead’s position in each channel to
determine a transformation that transforms data from one channel to match the
other channel. The <a class="reference internal" href="#sdt.channel_reg.Registrator" title="sdt.channel_reg.Registrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Registrator</span></code></a> class offers an easy way to do this.</p>
<p class="rubric">Examples</p>
<p>Let’s assume that multiple images/sequences of flourescent beads have been
acquired with two color channels on in the same image. First, the beads
need to be localized (e.g. using the <code class="docutils literal notranslate"><span class="pre">sdt.gui.locator</span></code> application).
These need to be loaded:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bead_loc</span> <span class="o">=</span> <span class="p">[</span><span class="n">sdt</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s2">&quot;beads*.h5&quot;</span><span class="p">)]</span>
</pre></div>
</div>
<p>Next, we define ROIs for the two channels using <a class="reference internal" href="roi.html#sdt.roi.ROI" title="sdt.roi.ROI"><code class="xref py py-class docutils literal notranslate"><span class="pre">sdt.roi.ROI</span></code></a> and
choose the bead localizations with respect to the ROIs:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r1</span> <span class="o">=</span> <span class="n">sdt</span><span class="o">.</span><span class="n">roi</span><span class="o">.</span><span class="n">ROI</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2</span> <span class="o">=</span> <span class="n">sdt</span><span class="o">.</span><span class="n">roi</span><span class="o">.</span><span class="n">ROI</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">200</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">beads_r1</span> <span class="o">=</span> <span class="p">[</span><span class="n">r1</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bead_loc</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">beads_r2</span> <span class="o">=</span> <span class="p">[</span><span class="n">r2</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bead_loc</span><span class="p">]</span>
</pre></div>
</div>
<p>Now, calculate the transform that overlays the two channels using
<a class="reference internal" href="#sdt.channel_reg.Registrator" title="sdt.channel_reg.Registrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Registrator</span></code></a>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">corr</span> <span class="o">=</span> <span class="n">Registrator</span><span class="p">(</span><span class="n">beads_r1</span><span class="p">,</span> <span class="n">beads_r2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corr</span><span class="o">.</span><span class="n">determine_parameters</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corr</span><span class="o">.</span><span class="n">test</span><span class="p">()</span>  <span class="c1"># Plot results</span>
</pre></div>
</div>
<p>This can now be used to transform i.e. image data from channel 1 so that it
can be overlaid with channel 1:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">pims</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;image.tif&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Load first frame (number 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_r1</span> <span class="o">=</span> <span class="n">r1</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>  <span class="c1"># Get channel 1 part of the image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_r2</span> <span class="o">=</span> <span class="n">r2</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>  <span class="c1"># Get channel 2 part of the image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_r1_corr</span> <span class="o">=</span> <span class="n">corr</span><span class="p">(</span><span class="n">img_r1</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Transform channel 1 image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">overlay</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">img_r1</span><span class="p">,</span> <span class="n">img_r2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">img_r1</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">overlay</span><span class="p">)</span>  <span class="c1"># Plot overlay</span>
</pre></div>
</div>
<p>Similarly, coordinates of single molecule data can be transformed:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">loc</span> <span class="o">=</span> <span class="n">sdt</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;loc.h5&quot;</span><span class="p">)</span>  <span class="c1"># Load data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">loc_r1</span> <span class="o">=</span> <span class="n">r1</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>  <span class="c1"># Get data from channel 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">loc_r2</span> <span class="o">=</span> <span class="n">r2</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>  <span class="c1"># Get data from channel 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">loc_r1_corr</span> <span class="o">=</span> <span class="n">corr</span><span class="p">(</span><span class="n">loc_r1</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Transform channel 1 data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">loc_r1_corr</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">loc_r1_corr</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;+&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">loc_r2</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">loc_r2</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>There is also support for saving and loading a <a class="reference internal" href="#sdt.channel_reg.Registrator" title="sdt.channel_reg.Registrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Registrator</span></code></a> instance
to/from YAML:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;output.yaml&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">sdt</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">yaml</span><span class="o">.</span><span class="n">safe_dump</span><span class="p">(</span><span class="n">corr</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">opon</span><span class="p">(</span><span class="s2">&quot;output.yaml&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">corr_loaded</span> <span class="o">=</span> <span class="n">sdt</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">yaml</span><span class="o">.</span><span class="n">safe_load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="programming-reference">
<h2>Programming reference<a class="headerlink" href="#programming-reference" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="sdt.channel_reg.Registrator">
<em class="property">class </em><code class="sig-prename descclassname">sdt.channel_reg.</code><code class="sig-name descname">Registrator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">feat1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">feat2</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">columns</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">channel_names</span><span class="o">=</span><span class="default_value">['channel1', 'channel2']</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/channel_reg.html#Registrator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.channel_reg.Registrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for easy overlay of two fluorescence microscopy channels</p>
<p>This class provides an easy-to-use interface to the registration
process. It is based on the algorithm published by Preibisch et al.
<a class="reference internal" href="#preibisch2010" id="id1"><span>[Preibisch2010]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>feat1</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>Sequence</em><em>[</em><em>pandas.core.frame.DataFrame</em><em>]</em><em>, </em><em>pandas.core.frame.DataFrame</em><em>]</em><em>]</em>) – Set the <cite>feat1</cite> and <cite>feat2</cite> attribute (turning it into a list
if it is a single DataFrame). Can also be <cite>None</cite>, but in this case
<a class="reference internal" href="#sdt.channel_reg.Registrator.find_pairs" title="sdt.channel_reg.Registrator.find_pairs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_pairs()</span></code></a> and <a class="reference internal" href="#sdt.channel_reg.Registrator.determine_parameters" title="sdt.channel_reg.Registrator.determine_parameters"><code class="xref py py-meth docutils literal notranslate"><span class="pre">determine_parameters()</span></code></a> will
not work. Defaults to <cite>None</cite>.</p></li>
<li><p><strong>feat2</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>Sequence</em><em>[</em><em>pandas.core.frame.DataFrame</em><em>]</em><em>, </em><em>pandas.core.frame.DataFrame</em><em>]</em><em>]</em>) – Set the <cite>feat1</cite> and <cite>feat2</cite> attribute (turning it into a list
if it is a single DataFrame). Can also be <cite>None</cite>, but in this case
<a class="reference internal" href="#sdt.channel_reg.Registrator.find_pairs" title="sdt.channel_reg.Registrator.find_pairs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_pairs()</span></code></a> and <a class="reference internal" href="#sdt.channel_reg.Registrator.determine_parameters" title="sdt.channel_reg.Registrator.determine_parameters"><code class="xref py py-meth docutils literal notranslate"><span class="pre">determine_parameters()</span></code></a> will
not work. Defaults to <cite>None</cite>.</p></li>
<li><p><strong>columns</strong> (<em>Dict</em>) – </p></li>
<li><p><strong>channel_names</strong> (<em>Sequence</em><em>[</em><em>str</em><em>]</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Other Parameters</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>columns</strong> – Override default column names as defined in
<code class="xref py py-attr docutils literal notranslate"><span class="pre">config.columns</span></code>. Relevant name are <cite>coords</cite> and <cite>time</cite>.
That means, if the DataFrames have coordinate columns “x” and “z”,
and a time column “alt_frame”, set
<code class="docutils literal notranslate"><span class="pre">columns={&quot;coords&quot;:</span> <span class="pre">[&quot;x&quot;,</span> <span class="pre">&quot;z&quot;],</span> <span class="pre">&quot;time&quot;:</span> <span class="pre">&quot;alt_frame&quot;}</span></code>. This is
used to set the <a class="reference internal" href="#sdt.channel_reg.Registrator.columns" title="sdt.channel_reg.Registrator.columns"><code class="xref py py-attr docutils literal notranslate"><span class="pre">columns</span></code></a> attribute.</p></li>
<li><p><strong>channel_names</strong> – Set the <cite>channel_names</cite> attribute. Defaults to <code class="docutils literal notranslate"><span class="pre">[&quot;channel1&quot;,</span>
<span class="pre">&quot;channel2&quot;]</span></code>.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="sdt.channel_reg.Registrator.feat1">
<code class="sig-name descname">feat1</code><a class="headerlink" href="#sdt.channel_reg.Registrator.feat1" title="Permalink to this definition">¶</a></dt>
<dd><p>Positions of beads (as found by a localization algorithm) in the first
channel. Each DataFrame corresponds to one image (sequence), thus multiple
bead images can be used to increase the accuracy.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sdt.channel_reg.Registrator.feat2">
<code class="sig-name descname">feat2</code><a class="headerlink" href="#sdt.channel_reg.Registrator.feat2" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <a class="reference internal" href="#sdt.channel_reg.Registrator.feat1" title="sdt.channel_reg.Registrator.feat1"><code class="xref py py-attr docutils literal notranslate"><span class="pre">feat1</span></code></a>, but for the second channel</p>
</dd></dl>

<dl class="py attribute">
<dt id="sdt.channel_reg.Registrator.columns">
<code class="sig-name descname">columns</code><a class="headerlink" href="#sdt.channel_reg.Registrator.columns" title="Permalink to this definition">¶</a></dt>
<dd><p>Column names in <a class="reference internal" href="#sdt.channel_reg.Registrator.feat1" title="sdt.channel_reg.Registrator.feat1"><code class="xref py py-attr docutils literal notranslate"><span class="pre">feat1</span></code></a> and <a class="reference internal" href="#sdt.channel_reg.Registrator.feat2" title="sdt.channel_reg.Registrator.feat2"><code class="xref py py-attr docutils literal notranslate"><span class="pre">feat2</span></code></a>. Defaults are
taken from <code class="xref py py-attr docutils literal notranslate"><span class="pre">config.columns</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sdt.channel_reg.Registrator.channel_names">
<code class="sig-name descname">channel_names</code><a class="headerlink" href="#sdt.channel_reg.Registrator.channel_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Channel names</p>
</dd></dl>

<dl class="py attribute">
<dt id="sdt.channel_reg.Registrator.pairs">
<code class="sig-name descname">pairs</code><a class="headerlink" href="#sdt.channel_reg.Registrator.pairs" title="Permalink to this definition">¶</a></dt>
<dd><p>Pairs found by <a class="reference internal" href="#sdt.channel_reg.Registrator.determine_parameters" title="sdt.channel_reg.Registrator.determine_parameters"><code class="xref py py-meth docutils literal notranslate"><span class="pre">determine_parameters()</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sdt.channel_reg.Registrator.parameters1">
<code class="sig-name descname">parameters1</code><a class="headerlink" href="#sdt.channel_reg.Registrator.parameters1" title="Permalink to this definition">¶</a></dt>
<dd><p>Array describing the affine transformation of data from channel 1 to
channel 2.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sdt.channel_reg.Registrator.parameters2">
<code class="sig-name descname">parameters2</code><a class="headerlink" href="#sdt.channel_reg.Registrator.parameters2" title="Permalink to this definition">¶</a></dt>
<dd><p>Array describing the affine transformation of data from channel 2 to
channel 1.</p>
</dd></dl>

<dl class="py method">
<dt id="sdt.channel_reg.Registrator.determine_parameters">
<code class="sig-name descname">determine_parameters</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n_neighbors</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="n">ambiguity_factor</span><span class="o">=</span><span class="default_value">5.0</span></em>, <em class="sig-param"><span class="n">max_error</span><span class="o">=</span><span class="default_value">1.0</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/channel_reg.html#Registrator.determine_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.channel_reg.Registrator.determine_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the parameters for the affine transformation</p>
<p>This takes the localizations of <a class="reference internal" href="#sdt.channel_reg.Registrator.feat1" title="sdt.channel_reg.Registrator.feat1"><code class="xref py py-attr docutils literal notranslate"><span class="pre">feat1</span></code></a> and tries to match
them with those of <a class="reference internal" href="#sdt.channel_reg.Registrator.feat2" title="sdt.channel_reg.Registrator.feat2"><code class="xref py py-attr docutils literal notranslate"><span class="pre">feat2</span></code></a>. Then a fit is used to determine
the affine transformation between the channels.</p>
<p>This is a convenience function that calls <a class="reference internal" href="#sdt.channel_reg.Registrator.find_pairs" title="sdt.channel_reg.Registrator.find_pairs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_pairs()</span></code></a> and
<a class="reference internal" href="#sdt.channel_reg.Registrator.fit_parameters" title="sdt.channel_reg.Registrator.fit_parameters"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit_parameters()</span></code></a>; see the documentation of the methods for
details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_neighbors</strong> (<em>int</em>) – Number of neighboring beads to consider to find matching features
across channels.</p></li>
<li><p><strong>ambiguity_factor</strong> (<em>float</em>) – A low value (around 1) will accept pairs even if there are similar
possible matches. The higher this value, the less are ambigous
results accepted.</p></li>
<li><p><strong>max_error</strong> (<em>float</em>) – Maximum error (i.e., distance between transformed position from
channel 1 and matched position in channel 2) to consider a feature
pair not an outlier and thus remove it from the transformation fit.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="sdt.channel_reg.Registrator.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">channel</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="n">inplace</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">mode</span><span class="o">=</span><span class="default_value">'constant'</span></em>, <em class="sig-param"><span class="n">cval</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">columns</span><span class="o">=</span><span class="default_value">{}</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/channel_reg.html#Registrator.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.channel_reg.Registrator.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Correct for chromatic aberrations</p>
<p>This can be done either on coordinates (e. g. resulting from feature
localization) or directly on raw images.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>Union</em><em>[</em><em>pandas.core.frame.DataFrame</em><em>, </em><em>sdt.roi.roi.PathROI</em><em>, </em><em>sdt.helper.slicerator.Slicerator</em><em>, </em><em>numpy.ndarray</em><em>]</em>) – Data to be processed. If a pandas.Dataframe, the feature
coordinates will be corrected. Otherwise,
<a class="reference internal" href="helper.html#sdt.helper.Pipeline" title="sdt.helper.Pipeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">sdt.helper.Pipeline</span></code></a> is used to correct image data using
an affine transformation.</p></li>
<li><p><strong>channel</strong> (<em>int</em>) – If <cite>features</cite> are in the first channel (corresponding to the
<cite>feat1</cite> arg of the constructor), set to 1. If features are in the
second channel, set to 2. Depending on this, a transformation will
be applied to the coordinates of <cite>features</cite> to match the other
channel (mathematically speaking depending on this parameter
either the “original” transformation or its inverse are applied.)</p></li>
<li><p><strong>inplace</strong> (<em>bool</em>) – Only has an effect if <cite>data</cite> is a DataFrame. If True, the
feature coordinates will be corrected in place.</p></li>
<li><p><strong>mode</strong> (<em>str</em>) – How to fill points outside of the uncorrected image boundaries.
Possibilities are “constant”, “nearest”, “reflect” or “wrap”.</p></li>
<li><p><strong>cval</strong> (<em>scalar</em><em> or </em><em>callable</em>) – What value to use for <cite>mode=”constant”</cite>. If this is callable, it
should take a single argument (the uncorrected image) and return a
scalar, which will be used as the fill value.</p></li>
<li><p><strong>columns</strong> (<em>Dict</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Other Parameters</dt>
<dd class="field-even"><p><strong>columns</strong> – Override default column names in case <cite>data</cite> is a
<code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>. The only relevant name is <cite>coords</cite>.
That means, if the DataFrame has coordinate columns “x” and “z”,
set <code class="docutils literal notranslate"><span class="pre">columns={&quot;coords&quot;:</span> <span class="pre">[&quot;x&quot;,</span> <span class="pre">&quot;z&quot;]}</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="sdt.channel_reg.Registrator.test">
<code class="sig-name descname">test</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ax</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/channel_reg.html#Registrator.test"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.channel_reg.Registrator.test" title="Permalink to this definition">¶</a></dt>
<dd><p>Test validity of the correction parameters</p>
<p>This plots the affine transformation functions and the coordinates of
the pairs that were matched in the channels. If everything went well,
the dots (i. e. pair coordinates) should lie on the line
(transformation function).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ax</strong> (<em>Optional</em><em>[</em><em>Sequence</em><em>]</em>) – Two matplotib axes instances for plotting. If <cite>None</cite>, allocate new
axes using <code class="xref py py-func docutils literal notranslate"><span class="pre">matplotlib.pyplot.subplots()</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="sdt.channel_reg.Registrator.save">
<code class="sig-name descname">save</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">file</span></em>, <em class="sig-param"><span class="n">fmt</span><span class="o">=</span><span class="default_value">'npz'</span></em>, <em class="sig-param"><span class="n">key</span><span class="o">=</span><span class="default_value">'chromatic_param1', 'chromatic_param2'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/channel_reg.html#Registrator.save"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.channel_reg.Registrator.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save transformation parameters to file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file</strong> (<em>Union</em><em>[</em><em>BinaryIO</em><em>, </em><em>str</em><em>, </em><em>pathlib.Path</em><em>]</em>) – File name or an open file-like object to save data to.</p></li>
<li><p><strong>fmt</strong> (<em>str</em>) – Format to save data. Either numpy (“npz”) or MATLAB (“mat”).
Defaults to “npz”.</p></li>
<li><p><strong>key</strong> (<a class="reference internal" href="loc.html#sdt.loc.z_fit.Parameters.Tuple" title="sdt.loc.z_fit.Parameters.Tuple"><em>Tuple</em></a><em>[</em><em>str</em><em>]</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Other Parameters</dt>
<dd class="field-even"><p><strong>key</strong> – Names of two transformations in the saved file.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="sdt.channel_reg.Registrator.load">
<em class="property">classmethod </em><code class="sig-name descname">load</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">file</span></em>, <em class="sig-param"><span class="n">fmt</span><span class="o">=</span><span class="default_value">'npz'</span></em>, <em class="sig-param"><span class="n">key</span><span class="o">=</span><span class="default_value">'chromatic_param1', 'chromatic_param2'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/channel_reg.html#Registrator.load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.channel_reg.Registrator.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Read paramaters from a file and construct a <cite>Registrator</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file</strong> (<em>Union</em><em>[</em><em>BinaryIO</em><em>, </em><em>str</em><em>, </em><em>pathlib.Path</em><em>]</em>) – File name or an open file-like object to load data from.</p></li>
<li><p><strong>fmt</strong> (<em>str</em>) – Format to save data. Either numpy (“npz”) or MATLAB (“mat”) or
<cite>determine_shiftstretch</cite>’s wrp (“wrp”). Defaults to “npz”.</p></li>
<li><p><strong>key</strong> (<a class="reference internal" href="loc.html#sdt.loc.z_fit.Parameters.Tuple" title="sdt.loc.z_fit.Parameters.Tuple"><em>Tuple</em></a><em>[</em><em>str</em><em>]</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p>A <a class="reference internal" href="#sdt.channel_reg.Registrator" title="sdt.channel_reg.Registrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Registrator</span></code></a> instance with the parameters read from the</p></li>
<li><p><em>file.</em></p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><p><strong>key</strong> – Name of the variables in the saved file (does not apply to “wrp”).
Defaults to (“chromatic_param1”, “chromatic_param2”).</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#sdt.channel_reg.Registrator" title="sdt.channel_reg.Registrator">sdt.channel_reg.Registrator</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="sdt.channel_reg.Registrator.find_pairs">
<code class="sig-name descname">find_pairs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n_neighbors</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="n">ambiguity_factor</span><span class="o">=</span><span class="default_value">5.0</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/channel_reg.html#Registrator.find_pairs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.channel_reg.Registrator.find_pairs" title="Permalink to this definition">¶</a></dt>
<dd><p>Match features of <cite>feat1</cite> with features of <cite>feat2</cite></p>
<p>Find the geomtric signature for each feature in each channel. Those
with best matching signatures are taken to be the same feature.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_neighbors</strong> (<em>int</em>) – Number of neighboring beads to consider for signature calculation.</p></li>
<li><p><strong>ambiguity_factor</strong> (<em>float</em>) – Accept only matches where the distance (with respect to the
geometric signature) between the beads of the second best match is
at least <code class="docutils literal notranslate"><span class="pre">ambiguity_factor</span></code> times as large as the distance for
the best match.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="sdt.channel_reg.Registrator.fit_parameters">
<code class="sig-name descname">fit_parameters</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">max_error</span><span class="o">=</span><span class="default_value">1.0</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/channel_reg.html#Registrator.fit_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.channel_reg.Registrator.fit_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine parameters for the affine transformation</p>
<p>An affine transformation is used to map x and y coordinates of <cite>feat1</cite>
to to those of <cite>feat2</cite>. This requires <a class="reference internal" href="#sdt.channel_reg.Registrator.pairs" title="sdt.channel_reg.Registrator.pairs"><code class="xref py py-attr docutils literal notranslate"><span class="pre">pairs</span></code></a> to be set, e.g.
by running <a class="reference internal" href="#sdt.channel_reg.Registrator.find_pairs" title="sdt.channel_reg.Registrator.find_pairs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_pairs()</span></code></a>.
The result is saved as <a class="reference internal" href="#sdt.channel_reg.Registrator.parameters1" title="sdt.channel_reg.Registrator.parameters1"><code class="xref py py-attr docutils literal notranslate"><span class="pre">parameters1</span></code></a> (transform of channel 1
coordinates to channel 2) and <a class="reference internal" href="#sdt.channel_reg.Registrator.parameters2" title="sdt.channel_reg.Registrator.parameters2"><code class="xref py py-attr docutils literal notranslate"><span class="pre">parameters2</span></code></a> (transform of
channel 2 coordinates to channel 1) attributes.</p>
<p><a class="reference internal" href="#sdt.channel_reg.Registrator.parameters1" title="sdt.channel_reg.Registrator.parameters1"><code class="xref py py-attr docutils literal notranslate"><span class="pre">parameters1</span></code></a> is calculated by determining the affine
transformation between the <a class="reference internal" href="#sdt.channel_reg.Registrator.pairs" title="sdt.channel_reg.Registrator.pairs"><code class="xref py py-attr docutils literal notranslate"><span class="pre">pairs</span></code></a> entries using a RANSAC
algorithm. <a class="reference internal" href="#sdt.channel_reg.Registrator.parameters2" title="sdt.channel_reg.Registrator.parameters2"><code class="xref py py-attr docutils literal notranslate"><span class="pre">parameters2</span></code></a> is its inverse. Therefore,
results may be slightly different depending on what is channel1 and
what is channel2.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>max_error</strong> (<em>float</em>) – Maximum error (i.e., distance between transformed position from
channel 1 and matched position in channel 2) to consider a feature
pair not an outlier.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="sdt.channel_reg.Registrator.to_yaml">
<em class="property">classmethod </em><code class="sig-name descname">to_yaml</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dumper</span></em>, <em class="sig-param"><span class="n">data</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/channel_reg.html#Registrator.to_yaml"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.channel_reg.Registrator.to_yaml" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump as YAML</p>
<p>Pass this as the <cite>representer</cite> parameter to your
<code class="xref py py-class docutils literal notranslate"><span class="pre">yaml.Dumper</span></code> subclass’s <cite>add_representer</cite> method.</p>
</dd></dl>

<dl class="py method">
<dt id="sdt.channel_reg.Registrator.from_yaml">
<em class="property">classmethod </em><code class="sig-name descname">from_yaml</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">loader</span></em>, <em class="sig-param"><span class="n">node</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/sdt/channel_reg.html#Registrator.from_yaml"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sdt.channel_reg.Registrator.from_yaml" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct from YAML</p>
<p>Pass this as the <cite>constructor</cite> parameter to your
<code class="xref py py-class docutils literal notranslate"><span class="pre">yaml.Loader</span></code> subclass’s <cite>add_constructor</cite> method.</p>
</dd></dl>

</dd></dl>

<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="preibisch2010"><span class="brackets"><a class="fn-backref" href="#id1">Preibisch2010</a></span></dt>
<dd><p>Preibisch, S.; Saalfeld, S.; Schindelin, J. &amp; Tomancak, P.:
“Software for bead-based registration of selective plane illumination
microscopy data”, Nature Methods, Springer Science and Business Media LLC,
2010, 7, 418–419</p>
</dd>
</dl>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="multicolor.html" class="btn btn-neutral float-right" title="Multi-color data analysis" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="roi.html" class="btn btn-neutral float-left" title="Regions of interest (ROIs)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2015—2018, Lukas Schrangl

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>